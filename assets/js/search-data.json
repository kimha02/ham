{
  
    
        "post0": {
            "title": "(공부) if문 & for문",
            "content": ". if&#47928; . - 예제1 . - a=11 처음에 선언 - a&lt;5, a&gt;10, 5&lt;=a=&lt;10 으로 나눠서 if문 작성 - **if, elif, else** 로 구분했다는 것을 기억해두자! . a=11 if a&lt;5: print(&#39;a=....1,2,3,4&#39;) elif a&gt;10: print(&#39;a=11,12,13,....&#39;) else: print(&#39;a=5,6,7,...,10&#39;) . a=11,12,13,.... . - 예제2 . - a,b=2,3이면 a=2, b=3으로 입력됨 - 크게 **if, else**로 나누고, **else 안에서 다시 if, else로 나눌 수 있다!** . a,b=5,2 if a==b: print(&#39;a=b&#39;) else: if a&lt;b: print(&#39;a&lt;b&#39;) else: print(&#39;a&gt;b&#39;) . a&gt;b . - 예제3 . - a==1이면 a=1을 출력 . a=1.0005 if a==1: print(&#39;a=1&#39;) . . for &#47928; . - 예제1 . - 리스트여도 잘 된다. . for i in [1,2,3,4]: print(i) . 1 2 3 4 . - 예제2 . - tuple이어도 잘 된다. . for i in (1,2,3,4): print(i) . 1 2 3 4 . - 예제3 . - string도 잘 된다. . for i in &#39;1234&#39;: print(i) . 1 2 3 4 . (?) 의문 . for i in ???: print(i) . 에서 물음표 자리에 올 수 있는 것이 무엇일까? . - 예제4 . a=5 for i in a: print(i) . TypeError Traceback (most recent call last) &lt;ipython-input-25-0141710f97f4&gt; in &lt;module&gt; 1 a=5 -&gt; 2 for i in a: 3 print(i) TypeError: &#39;int&#39; object is not iterable . 5라고 출력될 줄 알았는데 아니었다. 무슨 차이인가? A : 길이가 정의되는 1차원 자료형 이상이어야 for문은 정의된다. | . 아래를 살펴보자. | . - 예제5 . L=[[1,2,3],[3,4,5]] . for i in L: print(i) . [1, 2, 3] [3, 4, 5] . import pandas as pd df=pd.DataFrame(L) . for i in df: print(i) . 0 1 2 . import numpy as np ndr=np.array(L) . for i in ndr: print(i) . [1 2 3] [3 4 5] . 1차원 자료형을 넣었지만 결과를 예측할 수 없었다. 결과를 어떻게 예상할 수 있을까? | . &#9733; for&#47928;&#51032; &#46041;&#51089;&#50896;&#47532; . 사실 ??? 자리에 올 수 있는 것은 dir()하여 __iter__()라는 메서드가 있는 object이다. | 이러한 오브젝트를 iterable한 오브젝트라고 한다. | . a=1 . dir(a) . [&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__and__&#39;, &#39;__bool__&#39;, &#39;__ceil__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__float__&#39;, &#39;__floor__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__index__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__invert__&#39;, &#39;__le__&#39;, &#39;__lshift__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__or__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;, &#39;__rand__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rfloordiv__&#39;, &#39;__rlshift__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__ror__&#39;, &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rrshift__&#39;, &#39;__rshift__&#39;, &#39;__rsub__&#39;, &#39;__rtruediv__&#39;, &#39;__rxor__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;__xor__&#39;, &#39;as_integer_ratio&#39;, &#39;bit_length&#39;, &#39;conjugate&#39;, &#39;denominator&#39;, &#39;from_bytes&#39;, &#39;imag&#39;, &#39;numerator&#39;, &#39;real&#39;, &#39;to_bytes&#39;] . 예상대로 int클래스의 인스턴스는 __iter__()가 없다. . - 위에서 정의한 L, df, ndr 는 모두 __iter__() 함수가 있다. 따라서 iterable한 오브젝트이다. . -&gt; iterable한 오브젝트는 iterator로 만들 수 있는 특징이 있다. . iterable한 오브젝트를 어떻게 iterator로 만드는가? | . dfiter1=df.__iter__() . dfiter1? . Type: generator String form: &lt;generator object RangeIndex.__iter__ at 0x7fa6071b6cf0&gt; Docstring: &lt;no docstring&gt; . - dfiter1은 generator라는 클래스에서 만들어진 인스턴스 오브젝트이다. . dir(dfiter1) . [&#39;__class__&#39;, &#39;__del__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__name__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__next__&#39;, &#39;__qualname__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;close&#39;, &#39;gi_code&#39;, &#39;gi_frame&#39;, &#39;gi_running&#39;, &#39;gi_yieldfrom&#39;, &#39;send&#39;, &#39;throw&#39;] . dfiter1.__next__() #next의 역할은 순서대로 계속 작업하는.. . StopIteration Traceback (most recent call last) /tmp/ipykernel_23225/135013321.py in &lt;module&gt; -&gt; 1 dfiter1.__next__() #next의 역할은 순서대로 계속 작업하는.. StopIteration: . dfiter2=iter(df) . ?dfiter2 . Type: generator String form: &lt;generator object RangeIndex.__iter__ at 0x7fa6404a54a0&gt; Docstring: &lt;no docstring&gt; . dfiter2.__next__() . StopIteration Traceback (most recent call last) /tmp/ipykernel_23225/2401884540.py in &lt;module&gt; -&gt; 1 dfiter2.__next__() StopIteration: . &#8211; for &#47928;&#51032; &#51089;&#46041;&#50896;&#47532; . for i in L: print(i) . (1) iter함수를 사용해서 L을 iterator로 만든다. . (2) iterator에서 .__next__()함수를 호출하고 결과를 i에 저장한 뒤에 for문 블 안에 있는 내용(들여쓰기 된 내용)을 실행한다. . (3) StopIteration 에러가 발생하면 for 문을 멈춘다. . Liter=iter(L) . ?Liter . Type: list_iterator String form: &lt;list_iterator object at 0x7fa6071bb880&gt; Docstring: &lt;no docstring&gt; . Liter.__next__() . StopIteration Traceback (most recent call last) /tmp/ipykernel_23225/3305166288.py in &lt;module&gt; -&gt; 1 Liter.__next__() StopIteration: . ndriter=iter(ndr) . print(ndriter.__next__()) . StopIteration Traceback (most recent call last) /tmp/ipykernel_23225/3774912080.py in &lt;module&gt; -&gt; 1 print(ndriter.__next__()) StopIteration: . range() . - for문의 정석은 아래와 같이 range() 를 사용하는 것이다. . for i in range(5): print(i) . 0 1 2 3 4 . - range(5)의 정체는 그냥 iterable object이다. . a=range(5) . - 그래서 언제든지 iterator로 바꿀 수 있다. . aiter=iter(a) . aiter . &lt;range_iterator at 0x7fa6071bbf90&gt; . aiter.__next__() . StopIteration Traceback (most recent call last) /tmp/ipykernel_23225/3185881957.py in &lt;module&gt; -&gt; 1 aiter.__next__() StopIteration: . &#51060;&#53552;&#47112;&#51060;&#53552;&#51032; &#44060;&#45392;&#51008; &#46356;&#48260;&#44613;&#50640; &#51025;&#50857;&#51060; &#44032;&#45733;&#54616;&#45796;. . for i in zip([1,2,3],&#39;abc&#39;): print(i) . (1, &#39;a&#39;) (2, &#39;b&#39;) (3, &#39;c&#39;) . zip([1,2,3],&#39;abc&#39;) . &lt;zip at 0x7fa6404bb580&gt; . 어차피 for i in ????: ????의 자리는 iterable object 자리이다. . z=zip([1,2,3],&#39;abc&#39;) . dir(z) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__next__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;] . - __next__()함수가 있음 $ to$ z자체가 iterable object 이면서 iterator였다. . z.__next__() . StopIteration Traceback (most recent call last) /tmp/ipykernel_23225/4267025455.py in &lt;module&gt; -&gt; 1 z.__next__() StopIteration: . - ???? 자리에 iterator 자체가와도 무방할것 같다. . - 확인 $ to$ 가능하다! . L=iter([1,2,3,4]) for i in L: print(i) . 1 2 3 4 .",
            "url": "https://kimha02.github.io/ham/python/2021/08/25/python-10.html",
            "relUrl": "/python/2021/08/25/python-10.html",
            "date": " • Aug 25, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "(공부) 문자열",
            "content": ". &#47928;&#51088;&#50676; &#50741;&#49496; . - 예제1: 한줄 띄우기 ( n) . &#39;오늘의점심 n카레라이스&#39; # n을 그냥 넣으면 안된다. . &#39;오늘의점심 n카레라이스&#39; . print(&#39;오늘의점심 n카레라이스&#39;) #print에 넣어주면 한 줄 넘어간다. . 오늘의점심 카레라이스 . – 예제2: 탭 ( t) . print(&#39;오늘의점심 t카레라이스&#39;) . 오늘의점심 카레라이스 . - 예제3: 이스케이프( 옵션을 나타내주고 싶을 때) . print(&#39;오늘의점심 n카레라이스&#39;) #역슬래쉬가 2개인데 출력은 한 개만 된다-&gt;역슬래쉬를 하나 더 넣어주면 옵션 확인 가능하다! . 오늘의점심 n카레라이스 . print(&#39; &#39;) . . print(&#39;오늘의점심&#39;카레라이스&#39;&#39;) #따옴표 안에 있는 내용을 출력하고 싶은데 오류가 난다, . File &#34;/tmp/ipykernel_662842/33763534.py&#34;, line 1 print(&#39;오늘의점심&#39;카레라이스&#39;&#39;) #따옴표 안에 있는 내용을 출력하고 싶은데 오류가 난다, ^ SyntaxError: invalid syntax . print(&#39;오늘의점심 &#39;카레라이스 &#39;&#39;) #해결1) 이스케이프 활용 . 오늘의점심&#39;카레라이스&#39; . print(&quot;오늘의점심&#39;카레라이스&#39;&quot;) #해결2) 큰 따옴표 안에 작은 따옴표 . 오늘의점심&#39;카레라이스&#39; . . &#47928;&#51088;&#50676; &#47700;&#49548;&#46300; . 1) .replace() . - 특정 문자열 대체 . - 예제1 . S = &#39;spammy&#39; S.replace(&#39;mm&#39;,&#39;xx&#39;) . &#39;spaxxy&#39; . – 예제2 . S = &#39;xxxxSPAMxxxxSPAMxxxx&#39; . S.replace(&#39;SPAM&#39;,&#39;EGGS&#39;) . &#39;xxxxEGGSxxxxEGGSxxxx&#39; . S.replace(&#39;SPAM&#39;,&#39;EGGS&#39;,1) #1개만 바꾼다. . &#39;xxxxEGGSxxxxSPAMxxxx&#39; . ?S.replace . Signature: S.replace(old, new, count=-1, /) Docstring: Return a copy with all occurrences of substring old replaced by new. count Maximum number of occurrences to replace. -1 (the default value) means replace all occurrences. If the optional argument count is given, only the first count occurrences are replaced. Type: builtin_function_or_method . 2) .find() . – 예제1 . S = &#39;xxxxSPAMxxxxSPAMxxxx&#39; . where=S.find(&#39;SPAM&#39;) #SPAM이 어디있는지 찾아줘! -&gt; 결과 : 4번째부터 시작되네 -&gt; 4를 where에저장 . S[where] #input : 4 -&gt; output : S(S의 4번째 문자가 &#39;S&#39;라서) . &#39;S&#39; . S[:where]+&#39;EGGS&#39;+S[(where+4):] #0~4까지 문자 출력 + EGGS 삽입 + 4+4번 문자부터 마지막까지 출력 . &#39;xxxxEGGSxxxxSPAMxxxx&#39; . 3) .join() . – 예제1 . &#39;-&#39;.join([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) # - 로 언급한 문자들을 결합시킨다 . &#39;a-b-c&#39; . s=&#39;-&#39; s.join([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) . &#39;a-b-c&#39; . – 예제2 . S=&#39;spammy&#39; . S . &#39;spammy&#39; . S[3:5] . &#39;mm&#39; . S[3:5]=&#39;xx&#39; . TypeError Traceback (most recent call last) &lt;ipython-input-34-84bfa6854842&gt; in &lt;module&gt; -&gt; 1 S[3:5]=&#39;xx&#39; TypeError: &#39;str&#39; object does not support item assignment . mm을 xx로 바꾸고 싶은데 문자열은 불변리스트라서 바꿀 수 없다. | . ★ 전략: 문자열을 잠시 가변객체인 리스트로 바꾼 뒤 리스트에서 자유롭게 편집하고 그 다음에 다시 문자열로 만들자. | . L=list(S) . L . [&#39;s&#39;, &#39;p&#39;, &#39;a&#39;, &#39;m&#39;, &#39;m&#39;, &#39;y&#39;] . L[3:5] . [&#39;m&#39;, &#39;m&#39;] . L[3:5]=[&#39;x&#39;,&#39;x&#39;] . L . [&#39;s&#39;, &#39;p&#39;, &#39;a&#39;, &#39;x&#39;, &#39;x&#39;, &#39;y&#39;] . S=&#39;&#39;.join(L) . S . &#39;spaxxy&#39; . 4) .split(&#39;,&#39;) . – 예제1 . s=&#39;bob,hacker,40&#39; . s.split(&#39;,&#39;) # , 로 분리된 s 텍스트 나누기 . [&#39;bob&#39;, &#39;hacker&#39;, &#39;40&#39;] . – 예제2 . s= &#39;aaa bbb ccc&#39; . s.split(&#39; &#39;) # &#39;공백&#39; 으로 분리된 s 텍스트 나누기 . [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;] . s.split() # &#39;공백&#39; 으로 분리된 s 텍스트 나누기 . [&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;] . s.split? . Signature: s.split(sep=None, maxsplit=-1) Docstring: Return a list of the words in the string, using sep as the delimiter string. sep The delimiter according which to split the string. None (the default value) means split according to any whitespace, and discard empty strings from the result. maxsplit Maximum number of splits to do. -1 (the default value) means no limit. Type: builtin_function_or_method . . &#47928;&#51088;&#50676; &#54252;&#47588;&#54021; . 1) &#54364;&#54788;&#49885; (&#47928;&#51088;&#50676;&#50640;&#49436; %&#50672;&#49328;&#51088; &#49324;&#50857;) . - 예제1 . &#39;age: %s&#39; % 39 # s : string의 약자로 문자열도 가능함, (굉장히 특별한 경우가 아니면) 얘만 알아도 된다! . &#39;age: 39&#39; . &#39;age: %d&#39; % 39.1359 #정수형 . &#39;age: 39&#39; . &#39;age: %f&#39; % 39.1359 #float형 . &#39;age: 39.135900&#39; . - 예제2 . &#39;addr: %s to %s&#39; % (&#39;seoul&#39;,&#39;jeonju&#39;) . &#39;addr: seoul to jeonju&#39; . 잘못된 사용예시1 . &#39;addr: %s to %s&#39; % [&#39;seoul&#39;,&#39;jeonju&#39;] . TypeError Traceback (most recent call last) /tmp/ipykernel_662842/655998447.py in &lt;module&gt; -&gt; 1 &#39;addr: %s to %s&#39; % [&#39;seoul&#39;,&#39;jeonju&#39;] TypeError: not enough arguments for format string . 잘못된 사용예시2 . &#39;addr: %s to %s&#39; % &#39;seoul&#39;,&#39;jeonju&#39; . TypeError Traceback (most recent call last) &lt;ipython-input-60-0c8ecede52e2&gt; in &lt;module&gt; -&gt; 1 &#39;addr: %s to %s&#39; % &#39;seoul&#39;,&#39;jeonju&#39; TypeError: not enough arguments for format string . &#39;addr: %s to %s&#39; . str . % 연산자는 왼쪽에 문자열 오브젝트, 그리고 오른쪽에는 명시적인 튜플이 있어야 연산이 진행된다. | . 연산자라는 포인트를 이해하면 아래와 같은 문법도 가능함을 알 수 있다. | . s = &#39;addr: %s to %s&#39; s % (&#39;seoul&#39;,&#39;jeonju&#39;) . &#39;addr: seoul to jeonju&#39; . 2) &#46357;&#49492;&#45320;&#47532; &#44592;&#48152; &#54252;&#47588;&#54021; . - 사실 명시적인 튜플이 오른쪽에 오지 않아도 연산이 가능하다..! - 반복작업에 적합 . - 예제1 . &#39;여기 %(food1)s 1개, %(food2)s 1개 주문이요&#39; % {&#39;food1&#39;:&#39;짜장면&#39;,&#39;food2&#39;:&#39;짬뽕&#39;} . &#39;여기 짜장면 1개, 짬뽕 1개 주문이요&#39; . &#39;여기 %(food1)s 1개, %(food2)s 1개 주문이요, 아.. 아니다. %(food1)s은 취소하고 그냥 %(food2)s 두개 주세요&#39; % {&#39;food1&#39;:&#39;짜장면&#39;,&#39;food2&#39;:&#39;짬뽕&#39;} . &#39;여기 짜장면 1개, 짬뽕 1개 주문이요, 아.. 아니다. 짜장면은 취소하고 그냥 짬뽕 두개 주세요&#39; . - 예제2 . mail=&#39;%(studentname)s 학생 안녕하세요 n저는 통계학과 최규빈 교수 입니다. n전공설계과목 지침에 따라 %(studentname)s학생과 2회 상담을 실시해야 합니다. n저는 %(day)s에 시간이 괜찮은데 %(studentname)s 학생도 그날 시간이 괜찮을까요? n&#39; . print(mail % {&#39;studentname&#39;:&#39;박혜원&#39;, &#39;day&#39;:&#39;5월31일&#39;}) . 박혜원 학생 안녕하세요 저는 통계학과 최규빈 교수 입니다. 전공설계과목 지침에 따라 박혜원학생과 2회 상담을 실시해야 합니다. 저는 5월31일에 시간이 괜찮은데 박혜원 학생도 그날 시간이 괜찮을까요? . print(mail % {&#39;studentname&#39;:&#39;강호동&#39;, &#39;day&#39;:&#39;6월3일&#39;}) . 강호동 학생 안녕하세요 저는 통계학과 최규빈 교수 입니다. 전공설계과목 지침에 따라 강호동학생과 2회 상담을 실시해야 합니다. 저는 6월3일에 시간이 괜찮은데 강호동 학생도 그날 시간이 괜찮을까요? . - 예제3 . import pandas as pd df=pd.DataFrame({&#39;studentname&#39;:[&#39;박혜원&#39;,&#39;강호동&#39;],&#39;day&#39;:[&#39;5월31일&#39;,&#39;6월3일&#39;]}) df . studentname day . 0 박혜원 | 5월31일 | . 1 강호동 | 6월3일 | . for i in [0,1]: print(mail % dict(df.iloc[i])) . 박혜원 학생 안녕하세요 저는 통계학과 최규빈 교수 입니다. 전공설계과목 지침에 따라 박혜원학생과 2회 상담을 실시해야 합니다. 저는 5월31일에 시간이 괜찮은데 박혜원 학생도 그날 시간이 괜찮을까요? 강호동 학생 안녕하세요 저는 통계학과 최규빈 교수 입니다. 전공설계과목 지침에 따라 강호동학생과 2회 상담을 실시해야 합니다. 저는 6월3일에 시간이 괜찮은데 강호동 학생도 그날 시간이 괜찮을까요? . 3) &#47700;&#49436;&#46300; . - 예제1 . mail=&#39;{studentname} 학생 안녕하세요 n저는 통계학과 최규빈 교수 입니다. n전공설계과목 지침에 따라 {studentname}학생과 2회 상담을 실시해야 합니다. n저는 {day}에 시간이 괜찮은데 {studentname} 학생도 그날 시간이 괜찮을까요? n&#39; . mail.format(studentname=&#39;박혜원&#39;,day=&#39;6월2일&#39;) #.format으로 정의 (% 연산자 사용안함) . &#39;박혜원 학생 안녕하세요 n저는 통계학과 최규빈 교수 입니다. n전공설계과목 지침에 따라 박혜원학생과 2회 상담을 실시해야 합니다. n저는 6월2일에 시간이 괜찮은데 박혜원 학생도 그날 시간이 괜찮을까요? n&#39; . mm=mail.format(studentname=&#39;박혜원&#39;,day=&#39;6월2일&#39;) . print(mm) . 박혜원 학생 안녕하세요 저는 통계학과 최규빈 교수 입니다. 전공설계과목 지침에 따라 박혜원학생과 2회 상담을 실시해야 합니다. 저는 6월2일에 시간이 괜찮은데 박혜원 학생도 그날 시간이 괜찮을까요? . – 예제2 . &#39;name:{},age:{},city:{}&#39;.format(&#39;Sponge bob&#39;,&#39;2&#39;,&#39;male&#39;) . &#39;name:Sponge bob,age:2,city:male&#39; .",
            "url": "https://kimha02.github.io/ham/python/2021/08/24/python-9.html",
            "relUrl": "/python/2021/08/24/python-9.html",
            "date": " • Aug 24, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "(공부) 네임스페이스 & 연산자오버로딩 & 도움말 추가하기",
            "content": ". &#50696;&#51228;1 . - 아래의 코드를 관찰하라. . class Testclass1: x=0 . Testclass1.x . 0 . a=Testclass1() . a.x . 0 . – Testclass1.x를 수정하면 a.x가 강제로 수정된다. . Testclass1.x=100 . a.x . 100 . - a.x를 수정한다고 하여 Testclass1.x가 강제로 수정되는 것은 아님 . a.x=200 . Testclass1.x . 100 . a.x . 200 . - 이건 왜이러지? . Testclass1.x=300 . a.x . 200 . - 아래의 상황과 비슷하다. . x=39 def nextyear(): y=x+1 print(x,y) nextyear() . 39 40 . x=39 def nextyear(): y=x+1 print(x,y) x=0 nextyear() . UnboundLocalError Traceback (most recent call last) &lt;ipython-input-13-9c5d2bc270db&gt; in &lt;module&gt; 5 print(x,y) 6 x=0 -&gt; 7 nextyear() &lt;ipython-input-13-9c5d2bc270db&gt; in nextyear() 2 x=39 3 def nextyear(): -&gt; 4 y=x+1 5 print(x,y) 6 x=0 UnboundLocalError: local variable &#39;x&#39; referenced before assignment . – [code1]은 잘 실행되는 코드다. . - [code2]는 실행되지 않는 코드다. . - [code2]와 [code1]의 차이점은 x=0이라는 코드가 추가로 포함되었는지 유무다. . – (헛소리) x=0 이 잘못된 코드다!! 이걸 실행하는 과정에서 문제가 생겼다!! . - (올바른소리) code1에서는 x는 global variable, code2에서는 x가 local variable 이라서 생기는 문제점이다. . x=39 def nextyear(): x=0 y=x+1 print(x,y) nextyear() . 0 1 . x . 39 . – 다시 우리의 예제로 돌아오자. . ### 시점1 class Testclass1: x=0 ### 시점2 a=Testclass1() ### 시점3 Testclass1.x=100 ### 시점4 a.x=200 ### 시점5 Testclass1.x=300 . 시점1 시점2 시점3 시점4 시점5 . Testclass1.x | 0 | 0 | 100 | 100 | 300 | . a.x | 값없음 | 0 | 100 | 200 | 200 | . a.x의 속성 | - | class | class | instance | instance | . – a.x가 클래스로부터 물려받은 속성인지 (그래서 클래스와 연결되어있는지) 아니면 instance가 독자적으로 가지고 있는 속성인지 어떻게 알 수 있을까? . class Testclass1: x=0 print(&#39;시점1&#39;,Testclass1.x) ### 시점2 a=Testclass1() print(&#39;시점2&#39;,Testclass1.x,a.x,a.__dict__) ### 시점3 Testclass1.x=100 print(&#39;시점3&#39;,Testclass1.x,a.x,a.__dict__) ### 시점4 a.x=200 print(&#39;시점4&#39;,Testclass1.x,a.x,a.__dict__) ### 시점5 Testclass1.x=300 print(&#39;시점5&#39;,Testclass1.x,a.x,a.__dict__) . 시점1 0 시점2 0 0 {} 시점3 100 100 {} 시점4 100 200 {&#39;x&#39;: 200} 시점5 300 200 {&#39;x&#39;: 200} . . &#50696;&#51228;2 . x=11 ## 전역변수 ... A def f(): x=22 ## 함수 f안에 설정된 지역변수 print(x) ## 전역에 x=11 있지만 함수안에 x=22가 있으므로 x=22를 사용. --&gt; 22출력됨 def g(): print(x) ## 함수 g안에 x를 찾아봤는데 없음 --&gt; 전역에서 x를 찾음 --&gt; x=11 --&gt; 11출력함. class Testclass2: x=33 ## 클래스 변수 ... B def m1(self): x=44 ## 메소드 변수 ... C def m2(self): self.x=44 ## 인스턴스 변수 ... D . - 결과를 관찰하고 해석해보자. . print(x) . 11 . . Note: 전역변수 출력 . f() . 22 . . Note: f에서 설정된 지역변수 22가 출력됨 . x . 11 . . Note: f내의 지역변수를 사용하여도 전역변수는 변하지 않음. (함수내부에서 선언된 x=22는 함수외부에 영향을 주지못함) . g() . 11 . . Note: g에서 설정된 지역변수가 따로 없으므로 전역변수 출력 . x,Testclass2.x . (11, 33) . . Note: 전역변수 x와 클래스오브젝트에 설정된 변수 x . a=Testclass2() (x,Testclass2.x,a.x),a.__dict__ . ((11, 33, 33), {}) . . Note: 전역변수, 클래스 오브젝트내의 변수, 인스턴스내의 변수. a.__dict__의 결과로 보아 인스턴스내의 변수는 클래스 오브젝트내의 변수를 빌려쓰고 있다. . Testclass2.x=200 (x,Testclass2.x,a.x),a.__dict__ . ((11, 200, 200), {}) . . Note: 클래스오브젝트에서 변수를 고치면 인스턴스에 영향을 미침 . a.m1() (x,Testclass2.x,a.x),a.__dict__ . ((11, 200, 200), {}) . . Note: 메소드 m1내에서 선언된 x=44라는 선언은 아무것도 변화시킬수 없음. . a.m2() (x,Testclass2.x,a.x),a.__dict__ . ((11, 200, 44), {&#39;x&#39;: 44}) . . Note: 메소드 m2에 있는 self.x는 결국 a.x라는 의미이고, 이 선언은 클래스오브젝트 내의 변수와 독립적으로 인스턴스오브젝트 내에서 통용되는 변수를 선언하는 것임. 이 선언의 결과는 a.__dict__의 출력결과에서도 확인가능. . Testclass2.x=300 (x,Testclass2.x,a.x),a.__dict__ . ((11, 300, 44), {&#39;x&#39;: 44}) . . Note: 이제는 a.x와 Testclass2.x 는 분리된 상태이므로, Testclass2.x의 값을 바꾸어도 a.x에는 값의 변화가 없음. . - 전역변수 &gt; 클래스변수 &gt; 인스턴스변수 &gt; 메소드변수 내용을 모르고 사용한다면 예상하지 못한 오류가 발생할 수 있으므로 조심해서 사용하자. . . &#50672;&#49328;&#51088; &#50724;&#48260;&#47196;&#46377; . - 아래의 코드를 관찰하자. . 1+1 . 2 . - 생각해보니까 1은 int class 에서 생성된 인스턴스이다. . - 코드를 관찰하니 instance와 instance를 +라는 연산이 연결하는 형태임. . class Student: def __init__(self,age=20.0,semester=1): self.age=age self.semester=semester def __add__(self,val): # val==0: 휴학 # val==1: 등록 if val==0: self.age=self.age +0.5 elif val==1: self.age=self.age+0.5 self.semester=self.semester+1 return self ### return을 통해 guebin+1도 Student Type이 된다 def __repr__(self): return &#39;나이: %s n학기: %s&#39; % (self.age,self.semester) . guebin=Student() . guebin.age . 20.0 . guebin.semester . 1 . guebin . 나이: 20.0 학기: 1 . type(guebin) . __main__.Student . guebin+1 . 나이: 20.5 학기: 2 . type(guebin+1) . __main__.Student . guebin+0 . 나이: 21.5 학기: 3 . guebin+0+0+0+0+1+0+1 . 나이: 25.0 학기: 5 . - 연산자 오버로드 핵심아이디어 . 클래스가 일반 파이썬 연산을 재정의하는 것 | 여기에서 연산은 단순히 더하기 빼기를 의미하는게 아니라, print(), +, [0] 와 같은 파이썬 내장문법을 모두 포괄하는 개념이라 이해하는 것이 옳다. | . guebin[0] . TypeError Traceback (most recent call last) &lt;ipython-input-44-961de20e3474&gt; in &lt;module&gt; -&gt; 1 guebin[0] TypeError: &#39;Student&#39; object is not subscriptable . class Student2(Student): def __getitem__(self,index): return [self.age,self.semester][index] . hynn=Student2() . hynn+1+1+0+0 . 나이: 22.0 학기: 3 . hynn[0] . 22.0 . hynn[1] . 3 . hynn[:] . [22.0, 3] . - 연산자 오버로딩을 이해하면 파이썬 전반에 대한 이해폭이 넓어진다. . import pandas as pd . df=pd.DataFrame({&#39;age&#39;:[20,21.5],&#39;semester&#39;:[1,2]}) . df.iloc[:,0] . 0 20.0 1 21.5 Name: age, dtype: float64 . . &#46020;&#50880;&#47568; &#51089;&#49457;&#48169;&#48277; . - 넘파이의 경우 아래와 같이 도움말이 잘 작성되어 있다. . import numpy as np a=np.array([1,2,3]) a? . Type: ndarray String form: [1 2 3] Length: 3 File: ~/anaconda3/envs/py38r40/lib/python3.8/site-packages/numpy/__init__.py Docstring: &lt;no docstring&gt; Class docstring: ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to a low-level method (`ndarray(...)`) for instantiating an array. For more information, refer to the `numpy` module and examine the methods and attributes of an array. Parameters - (for the __new__ method; see Notes below) shape : tuple of ints Shape of created array. dtype : data-type, optional Any object that can be interpreted as a numpy data type. buffer : object exposing buffer interface, optional Used to fill the array with data. offset : int, optional Offset of array data in buffer. strides : tuple of ints, optional Strides of data in memory. order : {&#39;C&#39;, &#39;F&#39;}, optional Row-major (C-style) or column-major (Fortran-style) order. Attributes - T : ndarray Transpose of the array. data : buffer The array&#39;s elements, in memory. dtype : dtype object Describes the format of the elements in the array. flags : dict Dictionary containing information related to memory use, e.g., &#39;C_CONTIGUOUS&#39;, &#39;OWNDATA&#39;, &#39;WRITEABLE&#39;, etc. flat : numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for assignment examples; TODO). imag : ndarray Imaginary part of the array. real : ndarray Real part of the array. size : int Number of elements in the array. itemsize : int The memory use of each array element in bytes. nbytes : int The total number of bytes required to store the array data, i.e., ``itemsize * size``. ndim : int The array&#39;s number of dimensions. shape : tuple of ints Shape of the array. strides : tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous ``(3, 4)`` array of type ``int16`` in C-order has strides ``(8, 2)``. This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time (``2 * 4``). ctypes : ctypes object Class containing properties of the array needed for interaction with ctypes. base : ndarray If the array is a view into another array, that array is its `base` (unless that array is also a view). The `base` array is where the array data is actually stored. See Also -- array : Construct an array. zeros : Create an array, each element of which is zero. empty : Create an array, but leave its allocated memory unchanged (i.e., it contains &#34;garbage&#34;). dtype : Create a data-type. Notes -- There are two modes of creating an array using ``__new__``: 1. If `buffer` is None, then only `shape`, `dtype`, and `order` are used. 2. If `buffer` is an object exposing the buffer interface, then all keywords are interpreted. No ``__init__`` method is needed because the array is fully initialized after the ``__new__`` method. Examples -- These examples illustrate the low-level `ndarray` constructor. Refer to the `See Also` section above for easier ways of constructing an ndarray. First mode, `buffer` is None: &gt;&gt;&gt; np.ndarray(shape=(2,2), dtype=float, order=&#39;F&#39;) array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: &gt;&gt;&gt; np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) . - 하지만 우리는? . hynn? . Type: Student2 String form: 나이: 22.0 학기: 3 Docstring: &lt;no docstring&gt; . - 우리도 도움말을 작성하고 싶다. . class Student2(Student): &#39;&#39;&#39; Student2는 Student의 개선 # Student 클래스의 기능 1. 출력기능 (__repr__) 2. 연산기능 (__add__): 학기와 나이를 카운트 Examples -- &gt;&gt;&gt; hynn=Student2() &gt;&gt;&gt; hynn+1 나이: 20.5 학기: 2 # Student2에서 추가된 기능 1. 인덱싱 &#39;&#39;&#39; def __getitem__(self,index): return [self.age,self.semester][index] . hynn=Student2() . hynn? . Type: Student2 String form: 나이: 20.0 학기: 1 Docstring: Student2는 Student의 개선 # Student 클래스의 기능 1. 출력기능 (__repr__) 2. 연산기능 (__add__): 학기와 나이를 카운트 Examples -- &gt;&gt;&gt; hynn=Student2() &gt;&gt;&gt; hynn+1 나이: 20.5 학기: 2 # Student2에서 추가된 기능 1. 인덱싱 . hynn=Student2(21,1) . hynn . 나이: 21 학기: 1 . hynn? . Type: Student2 String form: 나이: 21 학기: 1 Docstring: Student2는 Student의 개선 # Student 클래스의 기능 1. 출력기능 (__repr__) 2. 연산기능 (__add__): 학기와 나이를 카운트 Examples -- &gt;&gt;&gt; hynn=Student2() &gt;&gt;&gt; hynn+1 나이: 20.5 학기: 2 # Student2에서 추가된 기능 1. 인덱싱 . . self&#50640; &#45824;&#54620; &#51652;&#49892; . – 사실 이름이 self가 아니어도 된다. . class MooYaHo: def __init__(a): a.text=&#39;mooyaho&#39; . moo1=MooYaHo() . moo1.text . – 일반적으로 사람들이 self를 많이 쓴다. a는 간단하게 정의할 때 많이 쓰이기 때문에 향후에 헛갈릴 수도 있다. .",
            "url": "https://kimha02.github.io/ham/python/2021/07/23/python-8.html",
            "relUrl": "/python/2021/07/23/python-8.html",
            "date": " • Jul 23, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "(공부) Class(클래스)_심화",
            "content": "&#53364;&#47000;&#49828;, &#51064;&#49828;&#53556;&#49828;, &#50724;&#48652;&#51229;&#53944; . - 오브젝트 . 클래스 오브젝트 | 인스턴스 오브젝트 | . - 클래스 (=클래스 오브젝트) . - 인스턴스 (=인스턴스 오브젝트) . &#53364;&#47000;&#49828; &#49549;&#49457; vs &#51064;&#49828;&#53556;&#49828; &#49549;&#49457; . 노트(5)에서 아래와 같은 노트가 있었다. | . 규칙2:클래스 내에서 정의한 변수 (예를들면 title, img, don)를 사용하려면 - self.title, self.img, self.don . - `MooYaHo.title`, `MooYaHo.img`, `MooYaHo.don` . $ to$ self.는 인스턴스 속성, MooYaHo.는 클래스 속성을 의미한다. . [&#50696;&#51228;1] . class Testclass1: x=0 y=0 def my_print(self): self.x += 1 Testclass1.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . f=Testclass1 . a=Testclass1() . b=f() ### f라는 클래스 오브젝트에서 b라는 인스턴트 오브젝트 생성 . a.my_print() . b.my_print() . b.my_print() . a.my_print() . a.my_print() . - 신기한 점: 각 인스턴스에서 instance.my_print()를 실행한 횟수를 서로 공유하는 듯 하다. . &#48516;&#49437; . - 코드를 시점별로 분석해보자. . - 분석을 위해서 커널을 재시작한다. . [시점1]: Testclass1를 선언하는 시점 . class Testclass1: x=0 y=0 def my_print(self): self.x += 1 Testclass1.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . dir(Testclass1) ###Testclass 탐색 . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;, &#39;x&#39;, &#39;y&#39;] . dir(a) . NameError Traceback (most recent call last) &lt;ipython-input-3-3af1c875b71a&gt; in &lt;module&gt; -&gt; 1 dir(a) NameError: name &#39;a&#39; is not defined . dir(b) . NameError Traceback (most recent call last) &lt;ipython-input-4-35660f044d44&gt; in &lt;module&gt; -&gt; 1 dir(b) NameError: name &#39;b&#39; is not defined . – 이 시점에는 Testclass1만이 존재한다. Testclass1를 바로 클래스 오브젝트 라고 부름. . Testclass1.x . 0 . Testclass1.y . 0 . – 현재시점에서는 클래스 오브젝트의 수 1개, 인스턴스 오브젝트의 수 0개, 따라서 총 오브젝트 수는 1개임. . [시점2] 클래스에 별칭을 지정하는 시점 . f=Testclass1 ###f라는 별칭을 지정 . f.x . 0 . f.y . 0 . Testclass1.x . 0 . Testclass1.y . 0 . – 이 시점에서 클래스 오브젝트는 2개가 있는 것 처럼 보인다. . - 그렇다면 이 2개의 클래스 오브젝트는 컴퓨터의 어딘가에 저장이 되어 있을 것이다. . - 구체적으로는 메모리에 저장되어 있을 것. . - 2개의 클래스오브젝트는 서로 다른 메모리 공간에 저장되어 있을 것이다. . - 진짜인가? 확인해보자. id()는 오브젝트(클래스 오브젝트, 인스턴스 오브젝트)가 저장된 메모리 주소를 확인하는 명령어이다. . id(f) . 93883369152752 . – f라는 오브젝트는 93883369152752 메모리에 저장되어 있다. . id(Testclass1) . 93883369152752 . - Testclass1의 오브젝트 역시 93883369152752 메모리에 저장되어 있다. . - 추론: 사실 93883369152752 라는 메모리공간에 저장된 어떠한 것은 동일한데, 그것을 어떤사람은 Testclass1 이라고 부르고 어떤사람은 f라고 부른다. . - 이는 마치 별명이랑 비슷하다. 부르는 이름이 2개라고 해서 나라는 오브젝트가 2개가 있는것은 아니다. . - 결국 이 시점에서 클래스 오브젝트의 수는 여전히 1개라고 볼 수 있다. (인스턴스 오브젝트의 수는 0개) . [시점3]: 클래스 오브젝트로부터 인스턴스 오브젝트를 만드는 시점 . a=Testclass1() b=f() . id(Testclass1),id(f),id(a),id(b) . (93883369152752, 93883369152752, 140489211063024, 140489211062064) . – 이 순간에는 클래스 오브젝트 1개, 인스턴스 오브젝트 2개 존재한다. 즉 총 3개의 오브젝트가 존재한다. . - 메모리주소 93883369152752 에 존재하는 오브젝트는 클래스 오브젝트이며 Testclass1 또는 f 라고 불린다. . - 메모리주소 140489211063024 에 존재하는 오브젝트는 인스턴스 오브젝트이며 a라고 불린다. . - 메모리주소 140489211062064 에 존재하는 오브젝트는 인스턴스 오브젝트이며 b라고 불린다. . Testclass1.x, Testclass1.y . (0, 0) . f.x,f.y . (0, 0) . a.x,a.y . (0, 0) . b.x,b.y . (0, 0) . [시점4] . a.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 1), (1, 1), (0, 1)) . - 특징 . a.my_print()를 실행하면 a.x 의 값이 1이 증가한다. | a.my_print()를 실행하면 f.y, a.y, b.y 의 값이 동시에 1이 증가한다. (공유가 되는 느낌) | . [시점5] . b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 2 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 2), (1, 2), (1, 2)) . [시점6] . b.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 3 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 3), (1, 3), (2, 3)) . [시점7] . a.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 4 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 4), (2, 4), (2, 4)) . [시점8] . a.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 5 회 출력 . (f.x,f.y),(a.x,a.y),(b.x,b.y) . ((0, 5), (3, 5), (2, 5)) . . [&#50696;&#51228;2] . - 아래처럼 코드를 바꿔도 잘 동작할것 같다. . class Testclass2: def __init__(self): self.x=0 self.y=0 def my_print(self): self.x += 1 Testclass2.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . c=Testclass2() . c.my_print() . AttributeError Traceback (most recent call last) &lt;ipython-input-35-5500abb1215d&gt; in &lt;module&gt; -&gt; 1 c.my_print() &lt;ipython-input-33-72dbe3bd77f6&gt; in my_print(self) 5 def my_print(self): 6 self.x += 1 -&gt; 7 Testclass2.y +=1 8 print(&#34;현재 인스턴스에서 %s 회 출력&#34; % self.x) 9 print(&#34;전체 인스턴스에서 총 %s 회 출력&#34; % self.y) AttributeError: type object &#39;Testclass2&#39; has no attribute &#39;y&#39; . – 왜 에러가 나는가? . dir(Testclass2) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;] . dir(Testclass1) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;, &#39;x&#39;, &#39;y&#39;] . - 관찰1: Testclass2에서는 Testclass1과는 다르게 x,y가 없다. . dir(c) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;my_print&#39;, &#39;x&#39;, &#39;y&#39;] . – 관찰2: 그런데 c라는 인스턴스 오브젝트에서는 x,y가 있다. . - 추론: __init__함수는 클래스 오브젝트가 만들어지는 시점에서는 실행되지 않고, 인스텐스 오브젝트가 만들어지는 시점에 실행된다. . - 결국 __init__함수의 역할은 클래스 오브젝트에서 인스턴스 오브젝트를 만든후에 초기화를 위해서 실행하는 어떠한 일련의 명령들을 묶어놓은 것에 불과하다. . – 즉 위의 코드는 굳이 따지면 아래를 실행한 것과 동일하다. . class Testclass2: # def __init__(self): # self.x=0 # self.y=0 def my_print(self): self.x += 1 Testclass2.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . c=Testclass2() . c.x=0 c.y=0 . - 이 상황에서 . c.my_print() . 를 실행하면 . c.x += 1 Testclass2.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % c.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % c.y) . 이 실행되는데, 이때 Testclass2.y 이 정의되어 있지 않으므로 . Testclass2.y +=1 . 에서 에러가 난다. . . [&#50696;&#51228; 3] . - 그렇다면 아래와 같이 수정하면 어떨까? . class Testclass3: def __init__(self): self.x=0 Testclass3.y=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) . a=Testclass3() b=Testclass3() . a.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 2 회 출력 . a.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 3 회 출력 . a.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 4 회 출력 . b.my_print() . 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 5 회 출력 . b.my_print() . 현재 인스턴스에서 3 회 출력 전체 인스턴스에서 총 6 회 출력 . – Testclass1과 동일한 기능이 수행되는것 같다. . - 그런데 조금만 생각해보면 엉터리라는 것을 알 수 있다. 아래의 코드를 관찰하여보자. . class Testclass3: def __init__(self): self.x=0 Testclass3.y=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) a=Testclass3() a.my_print() a.my_print() b=Testclass3() b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 2 회 출력 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . - Testclass3는 인스턴스를 생성할때마다 y=0이 설정된다. 그래서 . b=Testclass3() . 이 시점에서 의도하지 않게 &#39;전체 인스턴스에서 출력된 횟수&#39;를 의미하는 y가 초기화되었다. . - 코드는 엉터리이지만, Testclass3은 의외로 분석할만한 가치가 있다. 특히 위의 실행결과를 시점별로 Testclass1과 비교해보면 재미있다. . Testclass1 &amp; Testclass3 &#48708;&#44368; . - Testclass1 . ### Testclass1 ## 시점1: 클래스 오브젝트 생성 class Testclass1: x=0 y=0 def my_print(self): self.x += 1 Testclass1.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) ## 시점2: 인스턴스 오브젝트 a를 생성 a=Testclass1() ## 시점3: a에서 메소드 실행 a.my_print() ## 시점4: a에서 메소드를 한번 더 실행 a.my_print() ## 시점5: 인스턴스 오브젝트 b를 생성 b=Testclass1() ## 시점6: b에서 메소드를 실행 b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 2 회 출력 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 3 회 출력 . 시점1 시점2 시점3 시점4 시점5 시점6 . Testclass1.x | 0 | 0 | 0 | 0 | 0 | 0 | . Testclass1.y | 0 | 0 | 1 | 2 | 2 | 3 | . a.x | 값없음 | 0 | 1 | 2 | 2 | 2 | . a.y | 값없음 | 0 | 1 | 2 | 2 | 3 | . b.x | 값없음 | 값없음 | 값없음 | 값없음 | 0 | 1 | . b.y | 값없음 | 값없음 | 값없음 | 값없음 | 2 | 3 | . – Testclass3 . #### Testclass3 ## 시점1: 클래스 오브젝트 생성 class Testclass3: def __init__(self): self.x=0 Testclass3.y=0 def my_print(self): self.x += 1 Testclass3.y +=1 print(&quot;현재 인스턴스에서 %s 회 출력&quot; % self.x) print(&quot;전체 인스턴스에서 총 %s 회 출력&quot; % self.y) ## 시점2: 인스턴스 오브젝트 a를 생성 a=Testclass3() ## 시점3: a에서 메소드 실행 a.my_print() ## 시점4: a에서 메소드를 한번 더 실행 a.my_print() ## 시점5: 인스턴스 오브젝트 b를 생성 b=Testclass3() ## 시점6: b에서 메소드를 실행 b.my_print() . 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 현재 인스턴스에서 2 회 출력 전체 인스턴스에서 총 2 회 출력 현재 인스턴스에서 1 회 출력 전체 인스턴스에서 총 1 회 출력 . 시점1 시점2 시점3 시점4 시점5 시점6 . Testclass3.x | 값없음 | 값없음 | 값없음 | 값없음 | 값없음 | 값없음 | . Testclass3.y | 값없음 | 0 | 1 | 2 | 0 | 1 | . a.x | 값없음 | 0 | 1 | 2 | 2 | 2 | . a.y | 값없음 | 0 | 1 | 2 | 0 | 1 | . b.x | 값없음 | 값없음 | 값없음 | 값없음 | 0 | 1 | . b.y | 값없음 | 값없음 | 값없음 | 값없음 | 0 | 1 | . – Testclass3.y가 업데이트 되면 a.y, b.y도 자동으로 업데이트 된다. .",
            "url": "https://kimha02.github.io/ham/python/2021/07/21/python-7.html",
            "relUrl": "/python/2021/07/21/python-7.html",
            "date": " • Jul 21, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "(공부) Class(클래스)_예제",
            "content": "[&#50696;&#51228;4] &#51064;&#49324;&#44288;&#47532; &#50696;&#51228; . 원시적인 형태의 클래스 $ to$ 복잡하고 다양한 속성과 기능을 가지는 클래스로 발전 | 클래스는 무에서 점차 발전해나가는 프로토타입과 같이 코드를 설계할 때 유리 | . Step1: &#51064;&#51201;&#49324;&#54637; &#51077;&#47141; . class Person: def __init__(self,name,job=None,pay=0): self.name=name self.job=job self.pay=pay . hd=Person(&#39;Hodong Kang&#39;) iu=Person(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person(&#39;Hyewon Park&#39;,pay=3000) . print(hd.name,hd.job,hd.pay) print(iu.name,iu.job,iu.pay) print(hynn.name,hynn.job,hynn.pay) . Hodong Kang None 0 Jieun Lee dev 5000 Hyewon Park None 3000 . Step2: &#47700;&#49548;&#46300; &#52628;&#44032; . 아이유의 연봉을 10퍼센트 올리고 싶다면? . iu.pay *= 1.1 . iu.pay . 5500.0 . --&gt; 클래스의 외부에서 클래스의 속성 (iu.pay)을 바꾸는 동작(=함수)을 하드코딩하는 것은 좋은 방법이 아니다. . 좀 더 좋은 방법은 클래스 내부에 함수를 선언하는 방법이다. . class Person: def __init__(self,name,job=None,pay=0): self.name=name self.job=job self.pay=pay def giveRaise(self,percent): self.pay *= (1+percent) . hd=Person(&#39;Hodong Kang&#39;) iu=Person(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person(&#39;Hyewon Park&#39;,pay=3000) . print(hd.name,hd.job,hd.pay) print(iu.name,iu.job,iu.pay) print(hynn.name,hynn.job,hynn.pay) . Hodong Kang None 0 Jieun Lee dev 5000 Hyewon Park None 3000 . iu.giveRaise(0.1) . print(iu.name,iu.job,iu.pay) . Jieun Lee dev 5500.0 . hynn.giveRaise(0.2) print(hynn.name,hynn.job,hynn.pay) . Hyewon Park None 3600.0 . giveRaise라는 함수를 클래스 내부에 정의하면 . (1) 자명한 입력은 넣지 않아도 된다. (self) . (2) 원래 아이유의 연봉을 올리기 위해 작성한 코드였는데, Hynn의 연봉도 올릴 수 있게 되었다. . note: 만약에 하드코딩을 했다면? . class Person: def __init__(self,name,job=None,pay=0): self.name=name self.job=job self.pay=pay iu=Person(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person(&#39;Hyewon Park&#39;,pay=3000) iu.pay *= 1.1 hynn.pay *= 1.2 . note2: 함수를 클래스 외부에 선언했다면? (암묵적 전달대상 / 암묵적 업데이트 대상을 매순간 명시해야함) . class Person: def __init__(self,name,job=None,pay=0): self.name=name self.job=job self.pay=pay def giveRaise(pay,percent) pay *= (1+percent) return pay iu=Person(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person(&#39;Hyewon Park&#39;,pay=3000) iu.pay *= giveRaise(iu.pay,0.1) hynn.pay *= giveRaise(hynn.pay,0.2) . Step3: &#50672;&#49328;&#51088; &#50724;&#48260;&#47196;&#46377; . 클래스의 정보를 확인하기 위해서는? . print(hd.name,hd.job,hd.pay) print(iu.name,iu.job,iu.pay) print(hynn.name,hynn.job,hynn.pay) . 이것도 어떻게 보면 코드의 낭비 아닌가? 어차피 Person에서 보고 싶은 정보란 뻔하다. . 소망: 만약에 아래와 같이 타이핑만 하면 원하는 정보가 알아서 출력되면 좋겠다. . print(hd) print(iu) print(hynn) . 우리의 소망은 불가능해 보인다. print 함수이고 함수의 기능을 바꾸려면 함수를 다시 정의해야한다. . 그런데 print는 결국 내장함수이므로, 우리의 소망을 실현하기 위해서는 파이썬에 내장된 함수를 바꿔야한다. . 가능하다고 하더라도 문제이다. 그전까지 작성한 코드는 모두 어떻게 되는지? . ?hd . Type: Person String form: &lt;__main__.Person object at 0x7fbf621bb100&gt; Docstring: &lt;no docstring&gt; . Type이 Person인 경우에 한정하여 print의 기능을 바꾼다면? . print 내장함수는 Person타입(=내가 만든 클래스의 이름)에서만 바뀐 기능을 수행하고, 그외에서는 일반적으로 동작 . 조금 특별한 함수 __str__ 개발! . class Person: def __init__(self,name,job=None,pay=0): self.name=name self.job=job self.pay=pay def giveRaise(self,percent): self.pay *= (1+percent) def __str__(self): return str(self.name)+str(self.job)+str(self.pay) . __str__의 특징 . self를 입력으로 받는다. | 출력의 형태가 항상 문자열이어야 한다. | . hd=Person(&#39;Hodong Kang&#39;) iu=Person(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person(&#39;Hyewon Park&#39;,pay=3000) . print(hynn) . Hyewon ParkNone3000 . 욕심: 보통 주피터 노트북과 같은 대화형 프롬프트에서는 print를 굳이 사용하지 않아도 원하는 출력결과를 쉽게 얻는다. . 우리가 만든 클래스는? . print(hd) . Hodong KangNone0 . hd . &lt;__main__.Person at 0x7fbf621bbd00&gt; . 아쉬운데?.. $ to$ __repr__ 함수 개발 . class Person: def __init__(self,name,job=None,pay=0): self.name=name self.job=job self.pay=pay def giveRaise(self,percent): self.pay *= (1+percent) def __repr__(self): return str(self.name)+str(self.job)+str(self.pay) . hd=Person(&#39;Hodong Kang&#39;) iu=Person(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person(&#39;Hyewon Park&#39;,pay=3000) . hd . Hodong KangNone0 . print(hd) . Hodong KangNone0 . 보통은 __repr__을 더 선호한다. . __repr__이 더 많은 디스플레이 케이스에서 적용 | 두 가지 서로 다른 형태로 디스플레이하는데 관심이 없음. | . Step 4: &#49345;&#49549; . print(hd)의 디스플레이 형태가 예쁘지 않음 --&gt; 수정해보자. . 잔기술1 . &#39;파이는 %s&#39; % 3.14 . &#39;파이는 3.14&#39; . 잔기술2 . print(&#39;나는 n최고다&#39;) . 나는 최고다 . class Person2(Person): def __repr__(self): return &#39;이름: %s n직업: %s n연봉: %s&#39; % (self.name,self.job,self.pay) . hd=Person2(&#39;Hodong Kang&#39;) iu=Person2(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person2(&#39;Hyewon Park&#39;,pay=3000) . hd . 이름: Hodong Kang 직업: None 연봉: 0 . iu . 이름: Jieun Lee 직업: dev 연봉: 5000 . hynn . 이름: Hyewon Park 직업: None 연봉: 3000 . hd,iu,hynn . (이름: Hodong Kang 직업: None 연봉: 0, 이름: Jieun Lee 직업: dev 연봉: 5000, 이름: Hyewon Park 직업: None 연봉: 3000) . Manager라는 클래스를 새로 만들자. . Person2와 동일한데, 연봉상승방법이 약간 다르다고 하자. . 나쁜코드 . class Manager(Person2): def giveRaise(self,percent,bonus=0.1): self.pay *= (1+percent+bonus) . hd=Manager(&#39;Hodong Kang&#39;, job=&#39;mgr&#39;, pay=8000) . hd . 이름: Hodong Kang 직업: mgr 연봉: 8000 . hd.giveRaise(0.1) . hd . 이름: Hodong Kang 직업: mgr 연봉: 9600.000000000002 . 연봉상승은 10%상승이지만 매니저는 기본적으로 10% 상승시키므로 총 상승분은 20% . 좀 더 좋은 코드 기존에 만들어놓은 함수를 이용하자! . class Manager(Person2): def giveRaise(self,percent,bonus=0.1): Person2.giveRaise(self,percent+bonus) . hd=Manager(&#39;Hodong Kang&#39;, job=&#39;mgr&#39;, pay=8000) . hd . 이름: Hodong Kang 직업: mgr 연봉: 8000 . hd.giveRaise(0.1) . hd . 이름: Hodong Kang 직업: mgr 연봉: 9600.0 . 만약에 우리회사의 모든 직원들의 연봉을 20%올리고 싶다면? . hd=Manager(&#39;Hodong Kang&#39;, job=&#39;mgr&#39;, pay=8000) iu=Person2(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person2(&#39;Hyewon Park&#39;,pay=3000) . hd,iu,hynn . (이름: Hodong Kang 직업: mgr 연봉: 8000, 이름: Jieun Lee 직업: dev 연봉: 5000, 이름: Hyewon Park 직업: None 연봉: 3000) . for ins in [hd,iu,hynn]: ins.giveRaise(0.2) . hd,iu,hynn . (이름: Hodong Kang 직업: mgr 연봉: 10400.0, 이름: Jieun Lee 직업: dev 연봉: 6000.0, 이름: Hyewon Park 직업: None 연봉: 3600.0) . 코드분석 . (1) ins는 Person2클래스의 인스턴스 혹은 Manager클래스의 인스턴스 . (2) 각 인스턴스는 각 클래스에 정의된 적당한 버전의 &#39;giveRaise&#39;를 활용하여 연봉이 인상된다. 즉 iu, hynn은 Person2버전의 giveRasie를 실행하고, hd는 Manager버전의 &#39;giveRaise&#39;를 실행 . (3) 출력은 모두 동일한 __repr__을 실행 . 클래스가 없다면? . (1) 함수의 암묵적인자를 전달하지 못하므로 코드가 길어진다. (self 인자) . (2) (hd, iu, hynn) 와 같이 같이 깔끔한 코드로 출력결과를 바로바로 확인하기가 불가능할 것이다. (연산자 오버로딩) . (3) 그 사람이 매니저인지 아닌지에 따라 연봉상승하는 방법이 다르므로, 어딘가에 if문을 넣어야 할 것이다. . (4) 코드의 재사용이 어렵다.. 디버깅이 어렵다.. 등등.. . . [$ ast$] __init__함수 재정의 . 생각해보니까 아래의 코드에서 호동의 직업을 매니저로 입력하는 것이 낭비같다. . hd=Manager(&#39;Hodong Kang&#39;, job=&#39;mgr&#39;, pay=8000) iu=Person2(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person2(&#39;Hyewon Park&#39;,pay=3000) . 호동은 매니저클래스의 인스턴스이므로 직업은 당연히 매니저일것. . 굳이 job=&#39;mgr&#39;와 같은 방식으로 입력하지 않아도 될것 같다. . 어떻게 하면 될까? . class Manager(Person2): def __init__(self,name,pay=0): self.name=name self.job=&#39;mgr&#39; self.pay=pay def giveRaise(self,percent,bonus=0.1): Person2.giveRaise(self,percent+bonus) . hd=Manager(&#39;Hodong Kang&#39;, pay=8000) iu=Person2(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person2(&#39;Hyewon Park&#39;,pay=3000) . hd . 이름: Hodong Kang 직업: mgr 연봉: 8000 . hd,iu,hynn . (이름: Hodong Kang 직업: mgr 연봉: 8000, 이름: Jieun Lee 직업: dev 연봉: 5000, 이름: Hyewon Park 직업: None 연봉: 3000) . 관찰: 아까 매니저 클래스에서 함수를 정의하는 과정을 잘 관찰하면 . class Manager(Person2): def giveRaise(self,percent,bonus=0.1): Person2.giveRaise(self,percent+bonus) . 상속받은 클래스(서브클래스)에서 슈퍼클래스이름.함수이름으로 슈퍼클래스의 함수를 호출함. . - __init__도 함수이므로 위와 같은 방식을 사용할 수 있겠다. . class Manager(Person2): def __init__(self,name,pay=0): Person2.__init__(self,name,&#39;mgr&#39;,pay) def giveRaise(self,percent,bonus=0.1): Person2.giveRaise(self,percent+bonus) . hd=Manager(&#39;Hodong Kang&#39;, pay=8000) iu=Person2(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person2(&#39;Hyewon Park&#39;,pay=3000) . hd,iu,hynn . (이름: Hodong Kang 직업: mgr 연봉: 8000, 이름: Jieun Lee 직업: dev 연봉: 5000, 이름: Hyewon Park 직업: None 연봉: 3000) . - giveRiase를 수정한 기법과 __init__을 수정한 기법은 동일함. . . [$ ast$] 객체임베딩(객체내장) . - 클래스 Person2를 상속받지 않고 사용할 수는 없을까? . - Person2를 인스턴스화 하고 그 인스턴스를 입력으로 받아 기능을 사용하는 방식을 취한다면? $ to$ 구현해보자. . - 원래코드 . class Manager(Person2): def __init__(self,name,pay=0): Person2.__init__(self,name,&#39;mgr&#39;,pay) def giveRaise(self,percent,bonus=0.1): Person2.giveRaise(self,percent+bonus) . - 아래와 같이 수정 . class Manager(): def __init__(self,name,pay=0): self.person2=Person2(name,&#39;mgr&#39;,pay) def giveRaise(self,percent,bonus=0.1): self.person2.giveRaise(self,percent+bonus) . hd=Manager(&#39;Hodong Kang&#39;, pay=8000) iu=Person2(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person2(&#39;Hyewon Park&#39;,pay=3000) . hd,iu,hynn . (&lt;__main__.Manager at 0x7fdea54ddbe0&gt;, 이름: Jieun Lee 직업: dev 연봉: 5000, 이름: Hyewon Park 직업: None 연봉: 3000) . hd.__repr__ . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;giveRaise&#39;, &#39;job&#39;, &#39;name&#39;, &#39;pay&#39;] . class Manager(): def __init__(self,name,pay=0): self.person2=Person2(name,&#39;mgr&#39;,pay) def giveRaise(self,percent,bonus=0.1): self.person2.giveRaise(self,percent+bonus) def __repr__(self): return str(self.person2) . hd=Manager(&#39;Hodong Kang&#39;, pay=8000) iu=Person2(&#39;Jieun Lee&#39;,job=&#39;dev&#39;,pay=5000) hynn=Person2(&#39;Hyewon Park&#39;,pay=3000) . hd,iu,hynn . (이름: Hodong Kang 직업: mgr 연봉: 8000, 이름: Jieun Lee 직업: dev 연봉: 5000, 이름: Hyewon Park 직업: None 연봉: 3000) . hd.person2.__repr__ . &lt;__main__.Manager at 0x7fdea54a1940&gt; . hd.__repr__ . &lt;__main__.Manager at 0x7fdea54a1940&gt; . - 이 예제에서는 임베딩기법이 그다지 유용하지 않다. . - 코드에 따라서 유용할수도있다. .",
            "url": "https://kimha02.github.io/ham/python/2021/07/21/python-6.html",
            "relUrl": "/python/2021/07/21/python-6.html",
            "date": " • Jul 21, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "(공부) Class(클래스)_이해",
            "content": "&#53364;&#47000;&#49828;&#46976; &#47924;&#50631;&#51064;&#44032;? . 많은 교재에서 정의를 회피함 | 비유적 설명 , 다른 대상을 가져와서 설명 클래스는 과자틀과 비슷하다. 클래스란 똑같은 무엇인가를 계속 만들어 낼 수도 있는 설계도면이고 객체란 클래스로 만든 피조물을 뜻한다. (점프투파이썬) | In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).` | . | . 직접적 설명 복제를 위한 확장가능한 프로그램 코드의 유닛 | . | . . &#50857;&#50612;&#51221;&#47532; . 클래스 인스턴스 . 과자틀 | 과자 | . 공장 | 공장에서 나온 생산품 | . 설계도 | 설계도 바탕으로 소프트웨어 세계에 구현된 실체 | . 프로그램 | 프로세스 | . . &#50724;&#45720;&#51032; &#50696;&#51228;&#45716; &#47924;&#50556;&#54840;~! . 밈_무야호의 탄생 과정 . (1) 무야호 원본 시청 . (2) 복사하고 싶은 속성을 추림 . (3) 복제가능한 어떤 밈(틀)을 만듬 . 틀1: 무야호~~~ -&gt; 그만큼 ~하셨다는거지? | 틀2: 무야호 + 영상샘플링 + 음악샘플링 | . (4) 밈으로부터 짤을 만든다. . 다시 말해, . (1) 개념의 인지 . (2) 복사하고 싶은 속성을 추림 . (3) 복사가능한 어떤 틀을 만듬 (=클래스를 정의) . (4) 틀에서 인스턴스를 만든다 (=클래스에서 인스턴스를 만든다) . . [&#50696;&#51228;1] . 무파마에 무야호 밈을 적용해보자 . [예비학습] 그림 불러오는 함수 . ! pip3 install image # PIL : python image library -&gt; image library 설치 . Collecting image Downloading image-1.5.33.tar.gz (15 kB) Collecting pillow Downloading Pillow-8.3.1-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.whl (3.0 MB) |████████████████████████████████| 3.0 MB 1.9 MB/s eta 0:00:01 Collecting django Downloading Django-3.2.5-py3-none-any.whl (7.9 MB) |████████████████████████████████| 7.9 MB 10.5 MB/s eta 0:00:01 |████████████████████████████▉ | 7.1 MB 10.5 MB/s eta 0:00:01 Requirement already satisfied: six in /home/khy/anaconda3/envs/py38r40/lib/python3.8/site-packages (from image) (1.16.0) Collecting sqlparse&gt;=0.2.2 Downloading sqlparse-0.4.1-py3-none-any.whl (42 kB) |████████████████████████████████| 42 kB 1.6 MB/s eta 0:00:01 Requirement already satisfied: pytz in /home/khy/anaconda3/envs/py38r40/lib/python3.8/site-packages (from django-&gt;image) (2021.1) Collecting asgiref&lt;4,&gt;=3.3.2 Downloading asgiref-3.4.1-py3-none-any.whl (25 kB) Building wheels for collected packages: image Building wheel for image (setup.py) ... done Created wheel for image: filename=image-1.5.33-py2.py3-none-any.whl size=19482 sha256=731adb6c12993075241d6d32bee228d3652bc2c0f793c21fa4c941ace88f6f23 Stored in directory: /home/khy/.cache/pip/wheels/ac/30/5c/a8b33888bea3507eda7c924a143d34b2390d2ca5b145b327b5 Successfully built image Installing collected packages: sqlparse, asgiref, pillow, django, image Successfully installed asgiref-3.4.1 django-3.2.5 image-1.5.33 pillow-8.3.1 sqlparse-0.4.1 . from PIL import Image Image.open(&#39;mooyaho1.jpg&#39;) # 그냥 불러오면 이미지가 너무 커서 결과 삭제 . Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) # 이미지 크기 조절 . &#47785;&#54364;: (1) &quot;&#45453;&#49900; &#47924;&#54028;&#47560;&quot;&#47484; &#52636;&#47141;&#54616;&#44256; (2) &#47924;&#50556;&#54840; &#44536;&#47548;&#51012; &#48372;&#50668;&#51468; (3) &quot;&#44536;&#47564;&#53372; &#47579;&#51080;&#51004;&#49884;&#45800;&#44144;&#51648;&quot; &#47196; &#47560;&#47924;&#47532; . &#52395; &#49884;&#46020; . title=&quot;농심 무파마&quot; img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) don=&quot;그만큼 맛있으시단거지&quot; . print(title) display(img) print(don) . 농심 무파마 . 그만큼 맛있으시단거지 . 짤을 변경하고 싶다면, 아래와 같이 수행하자. | . title=&quot;속 시원한 농심 무야호&quot; print(title) display(img) print(don) . 속 시원한 농심 무야호 . 그만큼 맛있으시단거지 . 첫 시도의 아쉬움 . 드립을 바꾼 여러 개의 짤을 관리하기 힘들다. | 불필요한 반복도 많다. print, display, print &lt;-- 짤을 만들때마다 반복 | 코드가 지저분하다. (디버깅이 힘들다) | . &#46160;&#48264;&#51704; &#49884;&#46020;: &#47784;&#46280; . import mooyaho . mooyaho.memeshow(mooyaho.title, mooyaho.img,mooyaho.don) . 농심 무파마 . 그만큼 맛있으시단거지 . 타이틀을 바꾸고싶다면? . mooyaho.title=&#39;속시원한 농심 무야호&#39; mooyaho.memeshow(mooyaho.title, mooyaho.img, mooyaho.don) . 속시원한 농심 무야호 . 그만큼 맛있으시단거지 . 두 번째 시도의 아쉬운 점 . 코드는 상대적으로 깔끔하지만, 함수부분이 조금 아쉽다. | 코드를 수정할 때 마다 커널재시작을 해야한다. | . &#49464;&#48264;&#51704; &#49884;&#46020;: &#53364;&#47000;&#49828; . 다시 밈으로 짤을 만드는 개념을 복습하면 아래와 같다. . (1) 무야호 원본 시청 . (2) 복사하고싶은 속성 추출 . (3) 복제가능한 어떤 틀(밈)을 만듬 . (4) 밈으로 부터 짤을 만든다. . (1) &#48373;&#51228;&#44032;&#45733;&#54620; &#53952;&#51012; &#47564;&#46308;&#51088;. = &#53364;&#47000;&#49828;&#47484; &#49440;&#50616;&#54616;&#51088; . class MooYaHo(): ### MooYaHo라는 이름을 가진 클래스 선언 title=&quot;농심 무파마&quot; ### 클래스안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 클래스안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 클래스안에서 정의된 변수3 def memeshow(self): ### 클래스안에서 정의된 함수* print(self.title) display(self.img) print(self.don) . 모듈버전과 비교해보자. . from PIL import Image title=&quot;농심 무파마&quot; ### 모듈안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 모듈안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 모듈안에서 정의된 변수3 def memeshow(title,img,don): ### 모듈안에서 정의된 함수 print(title) display(img) print(don) . -&gt; 모듈버전이랑 비교하니까 함수부분이 조금 다르다. . 혹시 모듈처럼 아래와 같이 클래스를 선언해도 되지 않나? . class MooYaHo(): ### MooYaHo라는 이름을 가진 클래스 선언 title=&quot;농심 무파마&quot; ### 클래스안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 클래스안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 클래스안에서 정의된 변수3 def memeshow(title,img,don): ### 클래스안에서 정의된 함수 print(title) display(img) print(don) . $ to$ 안된다... (자세한 이유는 나중에) . 규칙1: 클래스내에서 함수를 선언하면 반드시 첫번째 인자는 self를 넣어야 한다. --&gt; self가 뭘까? . 규칙2: 클래스 내에서 정의한 변수 (예를들면 title, img, don)를 사용하려면 . self.title, self.img, self.don | MooYaHo.title, MooYaHo.img, MooYaHo.don | . (2) &#48136;&#51004;&#47196; &#48512;&#53552; &#51684;&#51012; &#47564;&#46304;&#45796;. (&#53364;&#47000;&#49828;&#47196;&#48512;&#53552; &#51064;&#49828;&#53556;&#49828;&#47484; &#49373;&#49457;&#54620;&#45796;.) . Step1: 클래스에서 인스턴스를 만듬 . Step2: 인스턴스에서 memeshow라는 함수를 사용 . 클래스에서 인스턴스를 찍어내는 방법 . 함수사용법과 비슷하다. | 클래스 이름을 쓰고 콘텐츠를 구체화시키는 과정에서 필요한 입력1, 입력2를 ()에 넣는다. | MooYaHo의 경우는 따로 입력이 없으므로, 그냥 MooYaHo하고 입력을 비워둔다. 즉 MooYaHo()로 생성 | . moo1=MooYaHo() ### 첫번째 인스턴스 생성 . moo1? . Type: MooYaHo String form: &lt;__main__.MooYaHo object at 0x7f9cc80c8580&gt; Docstring: &lt;no docstring&gt; . Type : Mooyaho ? 우리가 아는 Type은 int, float, list $ to$ int가 Class 이름이었나? $ to$ 나중에 설명 . 밈의 속성 확인 . moo1.하고 탭을 눌러보자. . moo1. . 주황색: don, img, title | 파란식: memeshow &lt;-- 함수 함수의 입력: self | 함수의 기능: print, display, print | . | . moo1.memeshow() . 농심 무파마 . 그만큼 맛있으시단거지 . . [$ star$] &#53364;&#47000;&#49828;&#51032; &#50948;&#47141; (&#51060;&#44152; &#45796;&#47480; &#48169;&#48277;&#51004;&#47196; &#50612;&#46523;&#44172; &#53076;&#46377;&#54644;&#50556; &#54624;&#51648; &#49345;&#49345;&#54644;&#48380;&#44163;) . 성능1: 인스턴스에서 .을 찍고 접근할 수 있는 여러 자료들을 정의할 수 있다. . moo1.title . &#39;농심 무파마&#39; . 성능2:인스턴스에서 .을 찍고 쓸 수 있는 자체적인 함수(=method라고 함)를 정의할 수 있다. . moo1.memeshow() . 농심 무파마 . 그만큼 맛있으시단거지 . 성능3: 짤의 내용을 쉽게 바꿀 수 있다. . moo1.title=&quot;속까지 시원해지는 농심 무야호&quot; . moo1.memeshow() . 속까지 시원해지는 농심 무야호 . 그만큼 맛있으시단거지 . moo1.don=&quot;그만큼 시원하시다는 거지&quot; moo1.memeshow() . 속까지 시원해지는 농심 무야호 . 그만큼 시원하시다는 거지 . 성능4: 여러짤을 동시에 쉽게 컨트롤 할 수 있다. . moo2=MooYaHo() moo3=MooYaHo() . moo2.title=&quot;오뚜기 진야호&quot; moo2.don=&quot;그만큼 진하시다는 거지~&quot; moo2.memeshow() . 오뚜기 진야호 . 그만큼 진하시다는 거지~ . moo3.title=&quot;팔도 비야호&quot; moo3.don=&quot;그만큼 비비고 싶으셨단 거지~&quot; moo3.memeshow() . 팔도 비야호 . 그만큼 비비고 싶으셨단 거지~ . moo2.memeshow() . 오뚜기 진야호 . 그만큼 진하시다는 거지~ . 성능 5: 틀의 재설계(밈의 재설계) $ star$$ star$$ star$ . 출력만 살짝 바꾸어서 MooYaHo2를 만들고 싶다. $ to$ MooYaHo의 모든 내용은 그대로 가져오고, 살짝만 다시 조정하면 된다. . #### 이런식으로 할 필요 없다. class MooYaHo2(): ### MooYaHo라는 이름을 가진 클래스 선언 title=&quot;농심 무파마&quot; ### 클래스안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 클래스안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 클래스안에서 정의된 변수3 def memeshow(self): ### 클래스안에서 정의된 함수* print(&#39;☆☆☆☆☆☆[&#39;+self.title+&#39;]☆☆☆☆☆☆&#39;) display(self.img) print(&#39;형돈:&#39;+self.don) . class MooYaHo2(MooYaHo): ### ()에mooyaho를 넣어서 내용을 가져온다. title, img, don 언급할 필요 없음 choi=&#39;무야~~~~~호~~~!!!&#39; ### 문장 추가 def memeshow(self): ### 클래스안에서 정의된 함수* print(&#39;☆☆☆☆☆☆[&#39;+self.title+&#39;]☆☆☆☆☆☆&#39;) display(self.img) print(self.choi) print(&#39;형돈:&#39;+self.don) . moo4=MooYaHo2() . moo4.memeshow() . ☆☆☆☆☆☆[농심 무파마]☆☆☆☆☆☆ . 무야~~~~~호~~~!!! 형돈:그만큼 맛있으시단거지 . moo5=MooYaHo2() . moo5.title=&#39;오뚜기 진야호&#39; moo5.don=&#39;그만큼 진하시다는 거지&#39; moo5.memeshow() # 내용도 쉽게 바꿀 수 있다 . ☆☆☆☆☆☆[오뚜기 진야호]☆☆☆☆☆☆ . 무야~~~~~호~~~!!! 형돈:그만큼 진하시다는 거지 . . [&#50696;&#51228;2] . import numpy class Meme: # class Meme(): n=0 title=&quot;농심&quot; def memeshow(self): self.n=self.n+1 print(self.title) print(&quot;*****&quot;) print(numpy.random.normal()) print(&quot;*****&quot;) print(str(self.n)+&#39;번째 짤&#39;) . ins1=Meme() . ins1.memeshow() . 농심 ***** -1.4375019518644987 ***** 4번째 짤 . ins2=Meme() . ins2.title=&#39;삼양&#39; . ins2.memeshow() . 삼양 ***** 1.277311593375453 ***** 1번째 짤 . ins2.n . 1 . ins1.n . 4 . self에 들어가야 했던 것은 사실 인스턴스 이름이었음. . 그런데 인스턴스 이름은 모른다. (내가 뭘로 만들지 알고? ) $ to$ self로 적는다. . . [&#50696;&#51228;3] . 아래코드가 아쉽다. . ins2=Meme() ins2.title=&#39;삼양&#39; . title의 디폴트가 &#39;농심&#39;이어야하는가? . 인스턴스를 만들때마다 타이틀을 새로 정하는 방식이 있으면 좋겠다. . __init__ 함수 개발!! . __init__ 함수란? . 몇 가지 사항을 빼고는 별다른 특별한 점이 없는 (어떠한 마법도 없는) 그냥 함수이다. | 인스턴스가 생성되는 시점에 자동으로 실행된다. | 특별한 첫번째 인자를 가진다. (self) | 클래스를 인스턴스화 할때 (...)의 값들을 함수의 입력으로 받는다. | . class Meme2: # class Meme2(): n=0 def __init__(self,title): self.title=title def memeshow(self): self.n=self.n+1 print(self.title) print(&quot;*****&quot;) print(numpy.random.normal()) print(&quot;*****&quot;) print(str(self.n)+&#39;번째 짤&#39;) . ins3=Meme2() . TypeError Traceback (most recent call last) &lt;ipython-input-51-06a02fb50ab1&gt; in &lt;module&gt; -&gt; 1 ins3=Meme2() TypeError: __init__() missing 1 required positional argument: &#39;title&#39; . ins3=Meme2(&#39;팔도&#39;) . ins3.title . &#39;팔도&#39; . ins3.memeshow() . 팔도 ***** 1.654463136086809 ***** 1번째 짤 . - 무슨일이 일어난 것일까? . (1) Meme2()를 인스턴스화 하는 순간에 __init__ 이 실행되어야 함. . (2) 그런데 __init__의 첫번째 인수인 self는 입력안해도 된다고 치고, 두번째 인수인 title은 입력으로 받았어야만 하는 것인데, 입력으로 받지 못하여 에러메시지 발생. . (3) 그럼 언제 __init__의 두번째 인수인 title을 넣어야할까? 곰곰히 생각해보니 Meme2를 인스턴스화 하는 순간에 입력으로 넣었어야 논리적으로 맞다. 즉 ins3=Meme2(&#39;팔도&#39;)와 같은 식으로 생성하는 순간 입력으로 넣어야 하는 것이었음. . (4) __init__의 두번째 인자가 &#39;팔도&#39;로 입력되었고, 이것이 self.title 즉 ins3.title에 바로 업데이트 된 상황임. . . &#53076;&#46300;&#51032; &#54952;&#50984;&#51201;&#51064; &#49688;&#51221; . class Meme2(Meme): # class Meme2(): def __init__(self,title): self.title=title . ins3=Meme2(&#39;팔도&#39;) . ins3.memeshow() . 팔도 ***** 0.13698357679308168 ***** 1번째 짤 . ins4=Meme2(&#39;오뚜기&#39;) . ins4.memeshow() . 오뚜기 ***** -0.7467284797015331 ***** 1번째 짤 . . 욕심: 타이틀이 없다고 에러메시지를 띄우는 것 보다 없으면 없는대로 만들어도 되지 않을까? . class Meme3(Meme): def __init__(self,title=None): self.title=title . ins5=Meme3() . ins5.title ### none이라 결과 안 뜬다 . ins5.memeshow() . None ***** 0.8480657490572441 ***** 1번째 짤 . ins5.title=&#39;야구르트&#39; . ins5.title . &#39;야구르트&#39; . ins5.memeshow() . 야구르트 ***** 0.11260958814531723 ***** 2번째 짤 .",
            "url": "https://kimha02.github.io/ham/python/2021/07/21/python-5.html",
            "relUrl": "/python/2021/07/21/python-5.html",
            "date": " • Jul 21, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "(공부) 파이썬 객체 소개_pandas",
            "content": "(1) dict&#51032; &#48373;&#49845; . dict를 선언하는 방법: . dict({&#39;a&#39;:[1,2,3], &#39;b&#39;:[2,3,4], &#39;c&#39;:[3,4,5]}) . {&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [2, 3, 4], &#39;c&#39;: [3, 4, 5]} . Q : dict는 왜 key:value의 집합으로 선언해야 하는가? . A : dict는 검색에 최적화되어있다. key로 접근하면 일일이 위치를 기억하지 않아도 원하는 정보를 얻을 수 있다. . (예제) . d={&#39;새로이&#39;:[30,600,4.0], &quot;이서&quot;:[20,950,4.2], &quot;일권&quot;:[28,950,2.3], &quot;현이&quot;:[28,650,3.8]} . d[&#39;이서&#39;] . [20, 950, 4.2] . &quot;이서&quot;로 검색을 하면 나이, 토익, 학점이 나온다. . 편하다. . (2) &#45436;&#51137;1 . 까칠이: list로 해도 충분히 가능하지 않나? . l=[[&#39;새로이&#39;,30,600,4.0], [&quot;이서&quot;,20,950,4.2], [&quot;일권&quot;,28,950,2.3], [&quot;현이&quot;,28,650,3.8]] . l[1] . [&#39;이서&#39;, 20, 950, 4.2] . 교과서: list는 &quot;이서&quot;의 위치를 알고 있어야 한다. dict는 &quot;이서&quot;의 위치를 몰라도, &quot;이서&quot;라는 키워드만 알면 정보를 얻을 수 있다. . 까칠이(넘파이,불인덱싱마스터): 아래처럼 하면 되는것 아닌가? . import numpy as np . l1=np.array(l) . l1 . array([[&#39;새로이&#39;, &#39;30&#39;, &#39;600&#39;, &#39;4.0&#39;], [&#39;이서&#39;, &#39;20&#39;, &#39;950&#39;, &#39;4.2&#39;], [&#39;일권&#39;, &#39;28&#39;, &#39;950&#39;, &#39;2.3&#39;], [&#39;현이&#39;, &#39;28&#39;, &#39;650&#39;, &#39;3.8&#39;]], dtype=&#39;&lt;U3&#39;) . l1.T . array([[&#39;새로이&#39;, &#39;이서&#39;, &#39;일권&#39;, &#39;현이&#39;], [&#39;30&#39;, &#39;20&#39;, &#39;28&#39;, &#39;28&#39;], [&#39;600&#39;, &#39;950&#39;, &#39;950&#39;, &#39;650&#39;], [&#39;4.0&#39;, &#39;4.2&#39;, &#39;2.3&#39;, &#39;3.8&#39;]], dtype=&#39;&lt;U3&#39;) . l1.T[0] . array([&#39;새로이&#39;, &#39;이서&#39;, &#39;일권&#39;, &#39;현이&#39;], dtype=&#39;&lt;U3&#39;) . l1.T[0]==&#39;이서&#39; . array([False, True, False, False]) . l1[l1.T[0]==&#39;이서&#39;] . array([[&#39;이서&#39;, &#39;20&#39;, &#39;950&#39;, &#39;4.2&#39;]], dtype=&#39;&lt;U3&#39;) . 교과서: 복잡하다.. dict는 이름만 알면 쉽게 정보검색 가능. . 까칠이: 나이가 28인 사람이 누군지 모두 알고 싶을 경우는? dict로 어떻게 하는지? . 교과서: ... . 까칠이(넘파이,불인덱싱마스터): 나는 할수 있다. . l1.T . array([[&#39;새로이&#39;, &#39;이서&#39;, &#39;일권&#39;, &#39;현이&#39;], [&#39;30&#39;, &#39;20&#39;, &#39;28&#39;, &#39;28&#39;], [&#39;600&#39;, &#39;950&#39;, &#39;950&#39;, &#39;650&#39;], [&#39;4.0&#39;, &#39;4.2&#39;, &#39;2.3&#39;, &#39;3.8&#39;]], dtype=&#39;&lt;U3&#39;) . l1.T[1] . array([&#39;30&#39;, &#39;20&#39;, &#39;28&#39;, &#39;28&#39;], dtype=&#39;&lt;U3&#39;) . l1.T[1]==&#39;28&#39; . array([False, False, True, True]) . l1[l1.T[1]==&#39;28&#39;] . array([[&#39;일권&#39;, &#39;28&#39;, &#39;950&#39;, &#39;2.3&#39;], [&#39;현이&#39;, &#39;28&#39;, &#39;650&#39;, &#39;3.8&#39;]], dtype=&#39;&lt;U3&#39;) . 교과서: ... . 까칠이: key를 사용하는 것이 왜 정보검색에 유리한것인지? . (3) &#45436;&#51137;2 . 사실 논쟁1에서 까칠이가 언급한 내용은 list의 장점이라기 보다 list와 호환성이 좋은 numpy의 장점이다. . dict도 dict와 호환성이 좋은 새로운 자료형이 있는데, 그것이 바로 pandas이다. . 근본적인 차이: list는 번호로, dict는 keyword로 접근한다. . 인덱싱, 슬라이싱 vs 맵핑 | . note: 리스트는 키워드로 정보검색이 불가능하다. . note: 딕셔너리는 인덱스로 정보검색이 불가능하다. . (4) pandas . import pandas as pd . d . {&#39;새로이&#39;: [30, 600, 4.0], &#39;이서&#39;: [20, 950, 4.2], &#39;일권&#39;: [28, 950, 2.3], &#39;현이&#39;: [28, 650, 3.8]} . pd.DataFrame(d) ## 판다스자료형 = 데이터프레임을 선언하는 방법 . 새로이 이서 일권 현이 . 0 30.0 | 20.0 | 28.0 | 28.0 | . 1 600.0 | 950.0 | 950.0 | 650.0 | . 2 4.0 | 4.2 | 2.3 | 3.8 | . df=pd.DataFrame(d).T . df . 0 1 2 . 새로이 30.0 | 600.0 | 4.0 | . 이서 20.0 | 950.0 | 4.2 | . 일권 28.0 | 950.0 | 2.3 | . 현이 28.0 | 650.0 | 3.8 | . note: 이서의 정보를 알고 싶다면? (딕셔너리 느낌) . df.loc[&#39;이서&#39;] . 0 20.0 1 950.0 2 4.2 Name: 이서, dtype: float64 . note: 칼럼이름을 정하고 싶다면? . df.columns=[&#39;age&#39;,&#39;toeic&#39;,&#39;gpa&#39;] . df . age toeic gpa . 새로이 30.0 | 600.0 | 4.0 | . 이서 20.0 | 950.0 | 4.2 | . 일권 28.0 | 950.0 | 2.3 | . 현이 28.0 | 650.0 | 3.8 | . note: 2번째 칼럼을 불러오자! (넘파이느낌) . df.iloc[:,1] . 새로이 600.0 이서 950.0 일권 950.0 현이 650.0 Name: toeic, dtype: float64 . note: 2-3번째 칼럼을 불러오자! (넘파이느낌) . df.iloc[:,1:3] . toeic gpa . 새로이 600.0 | 4.0 | . 이서 950.0 | 4.2 | . 일권 950.0 | 2.3 | . 현이 650.0 | 3.8 | . note: 토익점수를 불러오고 싶다면? . df.loc[:,&#39;toeic&#39;] . 새로이 600.0 이서 950.0 일권 950.0 현이 650.0 Name: toeic, dtype: float64 . note: age~toeic까지의 정보를 얻고 싶다면? . df.loc[:,&#39;age&#39;:&#39;toeic&#39;] . age toeic . 새로이 30.0 | 600.0 | . 이서 20.0 | 950.0 | . 일권 28.0 | 950.0 | . 현이 28.0 | 650.0 | . note: 새로이~일권까지의 정보를 얻고 싶다면? . df.loc[&#39;새로이&#39;:&#39;일권&#39;,:] . age toeic gpa . 새로이 30.0 | 600.0 | 4.0 | . 이서 20.0 | 950.0 | 4.2 | . 일권 28.0 | 950.0 | 2.3 | . note: 토익점수가 800보다 높은사람을 부르고 싶다면? . df . age toeic gpa . 새로이 30.0 | 600.0 | 4.0 | . 이서 20.0 | 950.0 | 4.2 | . 일권 28.0 | 950.0 | 2.3 | . 현이 28.0 | 650.0 | 3.8 | . df.query(&#39;toeic&gt;800&#39;) . age toeic gpa . 이서 20.0 | 950.0 | 4.2 | . 일권 28.0 | 950.0 | 2.3 | . note: 나이가 23보다 큰 사람을 부르고 싶다면? . df.query(&#39;age&gt;23&#39;) . age toeic gpa . 새로이 30.0 | 600.0 | 4.0 | . 일권 28.0 | 950.0 | 2.3 | . 현이 28.0 | 650.0 | 3.8 | . note: 나이가 23보다 많고 토익점수가 800보다 높은 사람을 부르고 싶다면? . df.query(&#39;age&gt;23 &amp; toeic&gt;800&#39;) . age toeic gpa . 일권 28.0 | 950.0 | 2.3 | .",
            "url": "https://kimha02.github.io/ham/python/2021/07/17/python-4.html",
            "relUrl": "/python/2021/07/17/python-4.html",
            "date": " • Jul 17, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "(공부) 파이썬 객체 소개_numpy",
            "content": "np.array . 욕심: (1,2,3)+(2,3,4)=(3,5,7)를 계산하고 싶다. . (실패) . a=[1,2,3] b=[2,3,4] a+b . [1, 2, 3, 2, 3, 4] . (성공) . [a[0]+b[0],a[1]+b[1],a[2]+b[2]] . [3, 5, 7] . (성공2) . a[0]+b[0],a[1]+b[1],a[2]+b[2] . (3, 5, 7) . temp_ = a[0]+b[0],a[1]+b[1],a[2]+b[2] . temp_ . (3, 5, 7) . list(temp_) . [3, 5, 7] . . 원소가 많을 경우 | . (실패) . c=[] for i in [0,1,2]: c[i]=a[i]+b[i] . IndexError Traceback (most recent call last) &lt;ipython-input-4-4af7fca0a837&gt; in &lt;module&gt; 1 c=[] 2 for i in [0,1,2]: -&gt; 3 c[i]=a[i]+b[i] IndexError: list assignment index out of range . c=[] c[0]=1 . IndexError Traceback (most recent call last) &lt;ipython-input-5-7a51dc8f9a26&gt; in &lt;module&gt; 1 c=[] -&gt; 2 c[0]=1 IndexError: list assignment index out of range . c=[] c=c+[1] . c . [1] . (성공) . c=[] for i in [0,1,2]: c=c+[a[i]+b[i]] . c . [3, 5, 7] . (성공) . a=[1,2,3] b=[2,3,4] c=[a[i]+b[i] for i in [0,1,2]] . c . [3, 5, 7] . . - np array 사용 . import numpy as np # np는 별칭(맨날 치기 귀찮으니까) . a=np.array((1,2,3)) #우리가 생각하는 벡터 형태, 리스트와 약간 다름! b=np.array([2,3,4]) . a+b . array([3, 5, 7]) . list - tuple - np.array사이에는 호환성이 좋음 . a=[1,2,3] . list(np.array(tuple(a))) . [1, 2, 3] . . 넘파이를 사용하면 벡터연산과 행렬연산을 쉽게 할 수 있다. . 예를들어 아래와 같은 문제가 있다고 하자. . $ begin{cases} w+2x+3y+4z=1 2w+2x+y=9 x-y=4 3w+x-y+3y=7 end{cases}$ . 매트릭스 형태로 위의 식을 표현하면 아래와 같다. . $ begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix} begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 9 4 7 end{bmatrix}$ . 양변에 $ begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix}$의 역행렬을 취하면 . $ begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix}^{-1} begin{bmatrix} 1 9 4 7 end{bmatrix}$ . A=[[1,2,3,4],[2,2,1,0],[0,1,-1,0],[3,1,-1,3]] . A . [[1, 2, 3, 4], [2, 2, 1, 0], [0, 1, -1, 0], [3, 1, -1, 3]] . list로 선언된 A를 np.matrix로 변환 . Amat=np.matrix(A) . Amat . matrix([[ 1, 2, 3, 4], [ 2, 2, 1, 0], [ 0, 1, -1, 0], [ 3, 1, -1, 3]]) . 변환된 매트릭스의 역행렬을 구함. . Amat.I . matrix([[-0.15789474, 0.26315789, -0.42105263, 0.21052632], [ 0.10526316, 0.15789474, 0.61403509, -0.14035088], [ 0.10526316, 0.15789474, -0.38596491, -0.14035088], [ 0.15789474, -0.26315789, 0.0877193 , 0.12280702]]) . b=[1,9,4,7] . bvec=np.matrix(b) . bvec . matrix([[1, 9, 4, 7]]) . bvec은 $1 times 4$ 매트릭스가 된 셈. . 그런데 우리가 원한것은 $4 times 1$ 매트릭스였음. . bvec=bvec.T bvec . matrix([[1], [9], [4], [7]]) . Amat.I*bvec . matrix([[ 2.], [ 3.], [-1.], [-1.]]) . $ begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix}^{-1} begin{bmatrix} 1 9 4 7 end{bmatrix}= begin{bmatrix} 2 3 -1 -1 end{bmatrix}$ . 따라서 $w=2, x=3, y=-1,z=-1$가 된다. . . [$ ast$] &#48176;&#50676; vs &#54665;&#47148; (np.array vs np.matrix) . 아래의 문제를 다시 살펴보자. . $ begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix} begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 9 4 7 end{bmatrix}$ . $(w,x,y,z)$를 풀기위해서는 . A=[[1,2,3,4],[2,2,1,0],[0,1,-1,0],[3,1,-1,3]] b=[1,9,4,7] Amat=np.matrix(A) bvec=np.matrix(b).T Amat.I * bvec . matrix([[ 2.], [ 3.], [-1.], [-1.]]) . 그런데 아래처럼 구해도 괜찮다. . A=[[1,2,3,4],[2,2,1,0],[0,1,-1,0],[3,1,-1,3]] b=[1,9,4,7] Aarr=np.array(A) barr=np.array(b) np.linalg.inv(Aarr) @barr # @는 연산자 . array([ 2., 3., -1., -1.]) . np.linalg.inv()가 통째로 역행렬을 구하는 함수다. . from numpy.linalg import inv A=[[1,2,3,4],[2,2,1,0],[0,1,-1,0],[3,1,-1,3]] b=[1,9,4,7] Aarr=np.array(A) barr=np.array(b) inv(Aarr) @ barr # 함수이름이 너무 길어서 줄여봤음 . array([ 2., 3., -1., -1.]) . 왜 np.matrix를 썼는가? . 행렬곱 | 역행렬계산 | . np.matrix가 진짜 편할까? . [불만1] 1차원자료형에 np.matrix를 쓰는게 이상하다. . barr.shape . (4,) . bvec.shape . (4, 1) . 이럴꺼면 굳이 1차원 자료형인 np.array를 왜 만드는지? . np.matrix([1,2,3])+np.matrix([4,5,6]) . matrix([[5, 7, 9]]) . [불만2] 3차원 자료가 있다면 어떻게 표현할래? $ to$ 확장성이 부족함 . B=[[[1,2],[2,3],[3,4]],[[3,2],[2,2],[4,1]]] . np.array(B)+100 . array([[[101, 102], [102, 103], [103, 104]], [[103, 102], [102, 102], [104, 101]]]) . np.matrix(B)+100 . ValueError Traceback (most recent call last) &lt;ipython-input-18-96c758f88605&gt; in &lt;module&gt; -&gt; 1 np.matrix(B)+100 ~/anaconda3/envs/py38r40/lib/python3.8/site-packages/numpy/matrixlib/defmatrix.py in __new__(subtype, data, dtype, copy) 147 shape = arr.shape 148 if (ndim &gt; 2): --&gt; 149 raise ValueError(&#34;matrix must be 2-dimensional&#34;) 150 elif ndim == 0: 151 shape = (1, 1) ValueError: matrix must be 2-dimensional . [불만3] np.array, np.matrix가 같이 있으면 혼란이 생긴다. col-vector, row-vector를 굳이 구분하고 싶지 않다. . 내적: $b= begin{bmatrix} 1 2 3 end{bmatrix}$라는 벡터가 있다고 하자. . 벡터의 크기의 제곱: $1^2+2^2+3^2$ . 벡터의 크기: $ sqrt{1^2+2^2+3^2}$ . b=[1,2,3] . np.array(b)@np.array(b) . 14 . $b= begin{bmatrix} 1 2 3 end{bmatrix}$, $b^T=[1,2,3]$ . $b^T b=[1,2,3] begin{bmatrix} 1 2 3 end{bmatrix}=1^2+2^2+3^2=14$ . $b b^T= begin{bmatrix} 1 2 3 end{bmatrix}[1,2,3]= begin{bmatrix}1 &amp; 2 &amp; 3 2 &amp; 4 &amp; 6 3 &amp; 6 &amp; 9 end{bmatrix}$ . b1=np.array(b) b2=np.matrix(b).T b1 . array([1, 2, 3]) . b2 . matrix([[1], [2], [3]]) . print(b2.T*b2) #... (1) print(b2*b2.T) #... (2) #print(b2*b2) ... (3) #print(b2.T*b2.T) ... (4) . [[14]] [[1 2 3] [2 4 6] [3 6 9]] . (1)~(4) 중에 무엇이 맞는 수식인지 따지고 싶지 않다. . b1@b1 #...(1) b1@b1.T #...(2) b1.T@b1 #...(3) b1.T@b1.T #...(4) . 14 . A=np.array([[1,0],[0,1]]) . A . array([[1, 0], [0, 1]]) . b=np.matrix([200,300]).T . A*b . matrix([[200], [300]]) . b*A # 위치를 바꿀 때 마다 형태를 변형해줘야 하는 불편함이 있음 . ValueError Traceback (most recent call last) &lt;ipython-input-36-865294475ca9&gt; in &lt;module&gt; -&gt; 1 b*A # 위치를 바꿀 때 마다 형태를 변형해줘야 하는 불편함이 있음 ~/anaconda3/envs/py38r40/lib/python3.8/site-packages/numpy/matrixlib/defmatrix.py in __mul__(self, other) 216 if isinstance(other, (N.ndarray, list, tuple)) : 217 # This promotes 1-D vectors to row vectors --&gt; 218 return N.dot(self, asmatrix(other)) 219 if isscalar(other) or not hasattr(other, &#39;__rmul__&#39;) : 220 return N.dot(self, other) &lt;__array_function__ internals&gt; in dot(*args, **kwargs) ValueError: shapes (2,1) and (2,2) not aligned: 1 (dim 1) != 2 (dim 0) . (3) &#51064;&#45937;&#49905; (&#49836;&#46972;&#51060;&#49905; &#54252;&#54632;) . A=np.array([[11,12,13,14,15],[21,22,23,24,25],[31,32,33,34,35]]) . A . array([[11, 12, 13, 14, 15], [21, 22, 23, 24, 25], [31, 32, 33, 34, 35]]) . [예제1] (3,1)에 접근하여 보자! . (방법1) . A[2] . array([31, 32, 33, 34, 35]) . A[2][0] . 31 . (방법2) . A[2,0] # list와의 차이점 : List에서는 불가능한 문법! . 31 . [예제2] 3행에 접근해보자. . (방법1) . A[2] . array([31, 32, 33, 34, 35]) . (방법2) . A[2,0:5] . array([31, 32, 33, 34, 35]) . (방법3) . A[2,:] . array([31, 32, 33, 34, 35]) . [예제3] 2열에 접근하여 보자. . (방법1) . A[:,1] . array([12, 22, 32]) . (?) 아래가 더 읽기 편하지 않나? . Amat=np.matrix(A) Amat[:,1] . matrix([[12], [22], [32]]) . (방법2) . A.T[1] . array([12, 22, 32]) . [예제4] 1행중에서 1,3,5열에 접근해보자. . (방법1) . A[0,[0,2,4]] . array([11, 13, 15]) . (방법2) . A[0][[0,2,4]] # 가로의 개수를 유지한다고 이해하자 . array([11, 13, 15]) . (방법3) . b=[0,2,4] . A[0][b] . array([11, 13, 15]) . (방법4) . A[0,b] . array([11, 13, 15]) . [예제5] (1,1),(1,2), (2,1),(2,2) 에 접근하자. . (방법1) . A . array([[11, 12, 13, 14, 15], [21, 22, 23, 24, 25], [31, 32, 33, 34, 35]]) . A[0:2,0:2] . array([[11, 12], [21, 22]]) . (방법2) . a=[0,1] b=[0,1] A[a,b] #(0,0), (1,1)이 뽑힌다 . array([11, 22]) . ??? 우리가 원하는게 아니다. . 깨달음! . # A[0,1] # A[1,0] # A[1,1] # * mac : cmd + / # * win : ctrl + / a=[0,0,1,1] b=[0,1,0,1] A[a,b] . array([11, 12, 21, 22]) . (방법3) . a=[0,1] b=[0,1] A[np.ix_(a,b)] . array([[11, 12], [21, 22]]) . np.ix_(a,b) . (array([[0], [1]]), array([[0, 1]])) . [예제6] . 홀수행, 짝수열을 뽑아보자. . 즉 12,32 14,34 가 뽑혀야함 . (방법1) . # A[2,1] # A[0,3] # A[2,3] . a=[0,2,0,2] b=[1,1,3,3] A[a,b] . array([12, 32, 14, 34]) . (방법2) . a=[0,2] # 1,3 행 ==&gt; 홀수행 b=[1,3] # 2,4 열 ==&gt; 짝수열 A[np.ix_(a,b)] . array([[12, 14], [32, 34]]) . [예제7] . 2행의 원소중 23보다 작은 원소만? . (방법1) . b=[0,1] A[1,b] . array([21, 22]) . 하지만 변수가 너무 많을 때는 위와 같이 계산하기당연히 어려움! . (방법2) . 아래를 관찰해보자. . c=np.random.normal(size=100) # np.random.normal(size=100)는 표준정규분포에서 100개의 난수를 생성하는 함수 . c&gt;0 #값이 아닌 T/F 결과를 보임 . array([False, True, True, False, False, True, False, True, True, False, True, False, True, False, True, True, False, True, True, False, True, False, True, True, True, True, False, True, True, False, False, False, True, False, True, False, False, False, False, False, False, False, True, False, False, True, True, False, False, True, False, False, False, True, True, True, True, True, False, False, True, False, True, True, False, True, False, True, False, True, True, True, False, True, True, True, False, False, True, False, False, True, False, True, True, False, True, False, True, True, True, True, False, False, True, False, False, True, True, True]) . c[c&gt;0] #boolIndexing-&gt;boolidx=c&gt;0 . array([0.18334984, 1.77051668, 2.01871979, 0.6618022 , 1.74088515, 0.67924512, 1.70566946, 0.92208578, 0.77595505, 0.30874189, 0.20613993, 0.0989423 , 0.89911795, 1.13985843, 1.21816941, 0.59673282, 0.13421594, 0.55343815, 1.55277558, 0.79995855, 1.43034953, 0.20047832, 1.4323895 , 0.78760893, 0.17690282, 0.75236525, 0.65544468, 1.28156261, 0.89955209, 0.87889443, 0.71509936, 0.12608794, 0.86428365, 0.45614107, 1.26244921, 0.14842187, 0.43357188, 1.03829107, 1.62379303, 0.91060634, 1.72900937, 0.52411524, 1.63818633, 0.34336474, 1.27008304, 0.32455862, 1.13402706, 1.43419411, 1.05120423, 0.02377782, 0.19521262, 1.73405291, 0.39269412]) . 이제 응용해보자. . # c&gt;0 --&gt; A[1]&lt;23 # c[c&gt;0]는 그러면 A[1][A[1]&lt;23] . array([21, 22]) . (방법3) . A[1,:][A[1,:]&lt;23] . array([21, 22]) . [$ ast$] &#51064;&#45937;&#49905;&#51032; &#51333;&#47448; ($ star star star$) . 기본인덱싱: 인덱스, 슬라이싱을 활용 예1: A[1,1] | 예2: A[1,0:2] | . | 팬시인덱싱(응용인덱싱): 인덱스를 정수배열로 전달, np.ix_함수를 활용한 인덱싱, 부울값 인덱싱 예1: A[0,[0,2,4]] , 정수배열 인덱싱 | 예2: A[np.ix_(a,b)] , np.ix함수를 활용한 인덱싱 | 예3: c[c&gt;0] , 부울값인덱싱 | . | (4) numpy&#47484; &#48176;&#50864;&#45716; &#48169;&#48277; . 인터넷+자동완성+contextual help 도움말을 보고 싶으면 ex)np.reshape ? 를 해도 볼 수 있다 . [$ ast$] 자동완성이 안되면 콘다환경에서 아래를 실행해볼것. . pip install &quot;jedi==0.17.2&quot; . a=np.array([1,2,3,2]) . np.amax(a) . 3 . np.reshape(a, [2,2]) # 행렬형태로 변환 가능함 . array([[1, 2], [3, 2]]) . a=np.array([[1,2,3], [4,5,6]]) a . array([[1, 2, 3], [4, 5, 6]]) . np.reshape(a, (3,2)) . array([[1, 2], [3, 4], [5, 6]]) .",
            "url": "https://kimha02.github.io/ham/python/2021/07/16/python-3.html",
            "relUrl": "/python/2021/07/16/python-3.html",
            "date": " • Jul 16, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "(공부) 파이썬 객체 소개_1차원 자료형",
            "content": "1&#52264;&#50896;&#51088;&#47308;&#54805; . (1) str . a=&#39;hayoung&#39; . a . &#39;hayoung&#39; . a=&#39;X&#39; b=&#39;2&#39; #2라는 문자 자체 . a+b #2문자가 합쳐진 모습으로 결과 도출 . &#39;X2&#39; . a-b #str에는 - 타입의 연산이 없음 . TypeError Traceback (most recent call last) &lt;ipython-input-75-a5eca377074f&gt; in &lt;module&gt; -&gt; 1 a-b #str에는 - 타입의 연산이 없음 TypeError: unsupported operand type(s) for -: &#39;str&#39; and &#39;str&#39; . a*b # a랑 b랑 곱해볼까? 곱도 안 된다! . TypeError Traceback (most recent call last) &lt;ipython-input-76-231357718326&gt; in &lt;module&gt; -&gt; 1 a*b # a랑 b랑 곱해볼까? 곱도 안 된다! TypeError: can&#39;t multiply sequence by non-int of type &#39;str&#39; . a*3 # a*3=a+a+a 이니까? . &#39;XXX&#39; . a=&#39;hayoung&#39; . a . &#39;hayoung&#39; . h a y o u n g . 0 | 1 | 2 | 3 | 4 | 5 | 6 | . 0 | -6 | -5 | -4 | -3 | -2 | -1 | . - 위 표를 통해 순서를 확인할 수 있다 . a[0] . &#39;h&#39; . a[0:3] # 0,1,2,3 의 인덱스가 아니라 0,1,2 . &#39;hay&#39; . a[1:3] # index 1부터시작해서 (3-1)개만큼 반환 . &#39;ay&#39; . a[:3] # =a[0:3] . &#39;hay&#39; . a[3:7] # =a[3:] . &#39;oung&#39; . a[1:-4] . &#39;ay&#39; . a[0:-6] . &#39;h&#39; . [$ ast$] 0&#52264;&#50896; vs 1&#52264;&#50896; . a=3.144 . len(a) #Int는 길이가 없음 . TypeError Traceback (most recent call last) &lt;ipython-input-16-d3d2954597f2&gt; in &lt;module&gt; -&gt; 1 len(a) #Int는 길이가 없음 TypeError: object of type &#39;float&#39; has no len() . a=&#39;3.144&#39; . len(a) #.도 포함되네! . 5 . a=&#39;1&#39; . len(a) . 1 . a=1 . len(a) . TypeError Traceback (most recent call last) &lt;ipython-input-121-1a2e6ec5f1e3&gt; in &lt;module&gt; -&gt; 1 len(a) TypeError: object of type &#39;int&#39; has no len() . a=&#39;hayoung&#39; . len(a) . 7 . . (2) list . - 자료를 추가 및 삭제할 때 편리함 . a=[11,22] . a . [11, 22] . b=[12,13] . $a=(11,12)$ . $b=(12,13)$ . $a+b=(23,25)$ . a+b . [11, 22, 12, 13] . a-b #연산 불가 . TypeError Traceback (most recent call last) &lt;ipython-input-129-5ae0619f8fe1&gt; in &lt;module&gt; -&gt; 1 a-b TypeError: unsupported operand type(s) for -: &#39;list&#39; and &#39;list&#39; . 2*a # a+a . [11, 22, 11, 22] . a+[33]+[345] #추가 . [11, 22, 33, 345] . c=[11,222,333] . c[0]+c[1] #c에서 0(1번째), 1(2번째)를 합하라 . 233 . list끼리는 수치적연산이 되지 않지만 list의 원소끼리는 수치연산이 가능할 수도 있음. . c1=11 c2=222 c3=333 . c=[c1,c2,c3] . c1+c2 # c[0]+c[1] . 233 . [$ ast$] list&#51032; &#50896;&#49548;&#45716; &#44845; &#49707;&#51088;&#54805;&#47564; &#44032;&#45733;&#54620; &#44163;&#51060; &#50500;&#45768;&#45796;. . list1=[1,3.14,True,&#39;a&#39;,[1,2],(1,2), {&#39;name&#39;:&#39;guebin&#39;,&#39;age&#39;:38},{1,2,3}] . l0=list1[0] l1=list1[1] l2=list1[2] l3=list1[3] l4=list1[4] l5=list1[5] l6=list1[6] l7=list1[7] . list2=[list1,3.14] . list2 . [[1, 3.14, True, &#39;a&#39;, [1, 2], (1, 2), {&#39;name&#39;: &#39;guebin&#39;, &#39;age&#39;: 38}, {1, 2, 3}], 3.14] . list2[1] . 3.14 . [$ ast$] &#47532;&#49828;&#53944; &#50896;&#49548; &#49688;&#51221; . - 스트링(str)에서는 원소 수정이 잘 되지 않음. . a=&#39;hayoung&#39; . a[0]=&#39;&#39; . TypeError Traceback (most recent call last) &lt;ipython-input-2-5690b0c929d5&gt; in &lt;module&gt; -&gt; 1 a[0]=&#39;&#39; TypeError: &#39;str&#39; object does not support item assignment . - 리스트형은 바꿀 수 있다. . alist=list(a) #각 글자를 원소화 . alist . [&#39;h&#39;, &#39;a&#39;, &#39;y&#39;, &#39;o&#39;, &#39;u&#39;, &#39;n&#39;, &#39;g&#39;] . alist[0] . &#39;h&#39; . alist[0]=&#39;H&#39; . alist . [&#39;H&#39;, &#39;a&#39;, &#39;y&#39;, &#39;o&#39;, &#39;u&#39;, &#39;n&#39;, &#39;g&#39;] . [$ ast$] &#47532;&#49828;&#53944; &#50896;&#49548; &#49325;&#51228; . alist . [&#39;H&#39;, &#39;a&#39;, &#39;y&#39;, &#39;o&#39;, &#39;u&#39;, &#39;n&#39;, &#39;g&#39;] . del alist[0] . alist . [&#39;a&#39;, &#39;y&#39;, &#39;o&#39;, &#39;u&#39;, &#39;n&#39;, &#39;g&#39;] . alist2=list(a) . alist2 . [&#39;h&#39;, &#39;a&#39;, &#39;y&#39;, &#39;o&#39;, &#39;u&#39;, &#39;n&#39;, &#39;g&#39;] . alist2=alist2[1:7] . alist2 . [&#39;a&#39;, &#39;y&#39;, &#39;o&#39;, &#39;u&#39;, &#39;n&#39;, &#39;g&#39;] . [$ ast$] &#47532;&#49828;&#53944; &#50896;&#49548; &#52628;&#44032; . a=[1,2,3] . a.append(4) . a . [1, 2, 3, 4] . a.append([4,5]) . a . [1, 2, 3, 4, [4, 5]] . a+[4,5] . [1, 2, 3, 4, [4, 5], 4, 5] . +연산자로 추가하는것과 .append 메소드로 추가하는 것의 차이점 . a=[1,2,3] . a.append(4) . a . [1, 2, 3, 4] . a1=[1,2,3] . a1+[4] . [1, 2, 3, 4] . a1 . [1, 2, 3] . a.append(4): a를 append하라. $ rightarrow$ a가 변함. . a+[4]: a와 [4]를 add하라. 기존 a는 변화 없음 . [$ ast$] &#47532;&#49828;&#53944;&#52980;&#54532;&#47532;&#54760;&#49496; ($ star star star$) . [예비학습]for문 벼락치기 . 프로그램 안에서 반복해서 무엇인가를 하고싶다? $ rightarrow$ for . for i in [0,1,2,3]: ## 반복실행계획 print(i) ## 반복실행내용 . 0 1 2 3 . i=0 print(i) i=1 print(i) i=2 print(i) i=3 print(i) . 0 1 2 3 . sumi=0 for i in [0,1,2,4]: ## 반복실행계획 sumi=sumi+i . sumi . 7 . sumi=0 i=0 sumi=sumi+i # 0+0 i=1 sumi=sumi+i # 0+1 i=2 sumi=sumi+i # 1+2 i=4 sumi=sumi+i # 3+4 . sumi . 7 . 예비학습 끝! . . [예제] $2^0,2^1,2^2,2^3,2^4,2^5$를 계산해보자. . (풀이1) - 진짜 나쁜코드 : 확장성이 부족함 . x=[2**0,2**1,2**2,2**3,2**4,2**5] . x . [1, 2, 4, 8, 16, 32] . (풀이2) - 그럭저럭 괜찮은 코드; for문을 이용했음. (버전1) . x=[] for i in [0,1,2,3,4,5]: x.append(2**i) . x . [1, 2, 4, 8, 16, 32] . (풀이2) - 그럭저럭 괜찮은 코드; for문을 이용했음. (버전2) . x=[] for i in [0,1,2,3,4,5]: x=x+[2**i] . x . [1, 2, 4, 8, 16, 32] . (풀이2) - 그럭저럭 괜찮은 코드; for문을 이용했음. (버전3) . x=[] for i in [0,1,2,3,4,5]: x+=[2**i] ### 암기법: x=x+[2**i] 에서 중복되는것을 제거하고 순서를 바꾼다... . x . [1, 2, 4, 8, 16, 32] . (풀이3) - 좋은 풀이; 리스트컴프리헨션을 이용 . x=[2**i for i in [0,1,2,3,4,5]] . x . [1, 2, 4, 8, 16, 32] . 문법을 암기하는 방법 . 조건제시법을 연상하라. | $ big {2^0,2^1,2^2,2^3,2^4,2^5 big }= big {2^i: i=0,1, dots, 5 big }$ | . 리스트 컴프리헨션 . 리스트를 매우 효율적으로 만드는 테크닉 | for문에 비하여 가지고 있는 장점: (1) 코드가 간단하다. (2) 빠르다. | . [예제] 리스트 컴프리핸션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;SSSS&#39;,&#39;PPPP&#39;,&#39;AAAA&#39;,&#39;MMMM&#39;] . [&#39;SSSS&#39;, &#39;PPPP&#39;, &#39;AAAA&#39;, &#39;MMMM&#39;] . (풀이) . [i*4 for i in &#39;SPAM&#39;] . [&#39;SSSS&#39;, &#39;PPPP&#39;, &#39;AAAA&#39;, &#39;MMMM&#39;] . [예제] 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라. . [&#39;X1&#39;,&#39;X2&#39;,&#39;X3&#39;,&#39;Y1&#39;,&#39;Y2&#39;,&#39;Y3&#39;] . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;] . (풀이) . [i+j for i in &#39;XY&#39; for j in &#39;123&#39;] . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;] . for i in [&#39;X&#39;,&#39;Y&#39;]: for j in &#39;123&#39;: print(i+j) . X1 X2 X3 Y1 Y2 Y3 . [$ ast$] &#47532;&#49828;&#53944;&#51032; &#51473;&#52393; ($ star star star$) . a=[[11,12,13], [21,22,23], [31,32,33]] . 0 1 2 . 0 | 11 | 12 | 13 | . 1 | 21 | 22 | 23 | . 2 | 31 | 32 | 33 | . a[0][0] . 11 . a[0][1] #0번열1번행 . 12 . . (3) tuple . - 리스트와 비슷하다. . 차이점1 : [ ] 대신에 ( )를 사용한다. . 차이점2 : 불변형이다. (값을 바꿀 수 없음) . a=(4,6,&quot;pencil&quot;,3.2+4.6j,[3,4]) . a[2] . &#39;pencil&#39; . a[0:3] . (4, 6, &#39;pencil&#39;) . a[2]=&quot;Pencil&quot; . TypeError Traceback (most recent call last) &lt;ipython-input-12-5ea264dc9819&gt; in &lt;module&gt; -&gt; 1 a[2]=&#34;Pencil&#34; TypeError: &#39;tuple&#39; object does not support item assignment . 참고로 리스트는 값이 잘 바뀜 . a=[4,6,&quot;pencil&quot;,3.2+4.6j,[3,4]] #리스트형 . a . [4, 6, &#39;pencil&#39;, (3.2+4.6j), [3, 4]] . a[2]=&quot;PENCIL&quot; . a . [4, 6, &#39;PENCIL&#39;, (3.2+4.6j), [3, 4]] . 차이점3 : 하나의 원소로 이루어진 튜플을 만들때는 쉼표를 붙여야 함. 쉼표를 넣지 않으면 int형으로 인식되어 +(더한) 값이 나온다. . a=[1] . a+[2] . [1, 2] . a=(1,) . a+(2,) . (1, 2) . 차이점4 : (의미가 명확할때) 튜플의 괄호는 생략가능하다. 의미가 명확할때 생략해야 한다! . a=1,2 . a . (1, 2) . 1,2 + 3,4,5 #2+3=5로 생각 . (1, 5, 4, 5) . (1,2) + (3,4,5) . (1, 2, 3, 4, 5) . 의문 튜플은 왜 쓰는가? . 튜플의 특징: 불변성$ rightarrow$ 실수로 값을 변경하지 않도록 방지할 수 있다? . [$ ast$] &#53916;&#54540;&#51008; &#45800;&#49692;&#55176; &#48520;&#48320;&#47532;&#49828;&#53944;&#44032; &#50500;&#45768;&#45796;. ($ star star star$) . [예제1]: 튜플언패킹 . name,age,sex,height,weight = &#39;Tom&#39;,20,&#39;M&#39;,180,70 . name . &#39;Tom&#39; . weight . 70 . [예제2] . coor=(33.9425,-118.408056) . coor . (33.9425, -118.408056) . lat, long = coor . lat . 33.9425 . long . -118.408056 . [예제3]: 임시변수 사용없이 두 변수의 값을 교환 . a=10 b=20 . a,b=b,a #실행순서가 오른쪽 임시 생성-&gt;왼쪽 적용 . a . 20 . b . 10 . [예제4]: 함수의 입력으로 튜플을 넣을때 . [예제4의 예비학습] 함수 벼락치기 . def cal(a,b): # def=함수선언, cal=함수이름 print(str(a) + &#39;+&#39; + str(b) + &#39;=&#39; + str(a+b)) print(str(a) + &#39;-&#39; + str(b) + &#39;=&#39; + str(a-b)) print(str(a) + &#39;*&#39; + str(b) + &#39;=&#39; + str(a*b)) print(str(a) + &#39;/&#39; + str(b) + &#39;=&#39; + str(a/b)) . cal(2,33) . 2+33=35 2-33=-31 2*33=66 2/33=0.06060606060606061 . input=[3,4] cal(input) . TypeError Traceback (most recent call last) &lt;ipython-input-38-da3b95adc570&gt; in &lt;module&gt; 1 ### 우리가 원하는 형태 : 알아서 인수를 분해해 계산해줬으면 좋겠지만... 2 input=[3,4] -&gt; 3 cal(input) TypeError: cal() missing 1 required positional argument: &#39;b&#39; . cal(input[0],input[1]) . 3+4=7 3-4=-1 3*4=12 3/4=0.75 . input=(3,4) . cal(*input) # *를 추가하면 튜플 언패킹 가능! . 3+4=7 3-4=-1 3*4=12 3/4=0.75 . [예제5] 함수의 입력을 튜플로 넣을때 (2) . 두점 사이의 거리를 구하는 함수를 만들어 보자. . $x=(x_1,x_2,x_3)$ . $y=(y_1,y_2,y_3)$ . 의 거리를 구하려면 . $ sqrt{(x_1-y_1)^2+(x_2-y_2)^2+(x_3-y_3)^2}$ . def distance(x1,x2,x3,y1,y2,y3): import math #라이브러리 부르고 d=(x1-y1)**2+(x2-y2)**2+(x3-y3)**2 #루트 아레 식 print(math.sqrt(d)) #math로 루트 계산 . x=(0,0,0) y=(0,1,1) distance(*x,*y) . 1.4142135623730951 . def distance(x,y): import math x1,x2,x3=x y1,y2,y3=y d=(x1-y1)**2+(x2-y2)**2+(x3-y3)**2 print(math.sqrt(d)) . distance(x,y) . 1.4142135623730951 . !!! &#54632;&#49688;&#47484; &#54840;&#52636;&#54624;&#46412; &#51064;&#49688;&#50526;&#50640; *&#47484; &#48537;&#50668; &#53916;&#54540;&#51012; &#50616;&#54056;&#53433;&#54624; &#49688; &#51080;&#45796;. . [예제6]: 플레이스홀더 . (예비학습) for문 . for i in [1,2,3,4]: print(i) . 1 2 3 4 . i=[1,2,3,4][0] print(i) i=[1,2,3,4][1] print(i) i=[1,2,3,4][2] print(i) i=[1,2,3,4][3] print(i) . 1 2 3 4 . for i in [1,2,3,[1,2,3]]: print(i) . 1 2 3 [1, 2, 3] . i=[1,2,3,[1,2,3]][0] print(i) i=[1,2,3,[1,2,3]][1] print(i) i=[1,2,3,[1,2,3]][2] print(i) i=[1,2,3,[1,2,3]][3] print(i) . 1 2 3 [1, 2, 3] . for i in [[1,22],[1,3],[2,14],[7,23]]: print(i) . [1, 22] [1, 3] [2, 14] [7, 23] . for i,j in [[1,22],[1,3],[2,14],[7,23]]: print(i) . 1 1 2 7 . i,j=[[1,22],[1,3],[2,14],[7,23]][0] print(i) i,j=[[1,22],[1,3],[2,14],[7,23]][1] print(i) i,j=[[1,22],[1,3],[2,14],[7,23]][2] print(i) i,j=[[1,22],[1,3],[2,14],[7,23]][3] print(i) . 1 1 2 7 . 예제시작 . idlist=[(&#39;guebin&#39;, &#39;202112345&#39;,&#39;M&#39;,&#39;Korea&#39;), (&#39;iu&#39;, &#39;202154321&#39;,&#39;F&#39;,&#39;Korea&#39;), (&#39;hodong&#39;, &#39;201812321&#39;,&#39;M&#39;,&#39;Korea&#39;)] . for i in idlist: print(i) . (&#39;guebin&#39;, &#39;202112345&#39;, &#39;M&#39;, &#39;Korea&#39;) (&#39;iu&#39;, &#39;202154321&#39;, &#39;F&#39;, &#39;Korea&#39;) (&#39;hodong&#39;, &#39;201812321&#39;, &#39;M&#39;, &#39;Korea&#39;) . for name,studentid,sex,nat in idlist: print(name) . guebin iu hodong . for name, _, _, _ in idlist: # 관심있는 것만 이름을 지정해주고 싶을 때 언더바 처리 print(name) . guebin iu hodong . &#50836;&#50557; . (1) 스트링, 튜플, 리스트는 모두 시퀀스형이라고 부른다. . (2) 시컨스형의 카테고리 . 컨테이너 시퀀스: list, tuple. | 균일(flat) 시퀀스: str | 가변 시퀀스: list | 불면 시퀀스: tuple, str | . 컨테이너 시퀀스 flat 시퀀스 . 가변 시퀀스 | list | - | . 불변 시퀀스 | tuple | str | . (3) 시퀀스형은 모두 인덱싱과 슬라이싱이 가능함. . a=1,2,3,4 . a . (1, 2, 3, 4) . a[0:3] . (1, 2, 3) . . (4) set . A={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;} #집합 . A . {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;} . B={&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;} . A.union(B) # union : 합집합, 중복원소는 제거 . {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;} . A|B # 요것도 합집합 . {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;} . A+B # 리스트처럼 +로 합집합이 되지 않음 . TypeError Traceback (most recent call last) &lt;ipython-input-62-f9b5070b2bad&gt; in &lt;module&gt; -&gt; 1 A+B # +로 합집합이 되지 않음 TypeError: unsupported operand type(s) for +: &#39;set&#39; and &#39;set&#39; . A.intersection(B) #교집합 . {&#39;c&#39;, &#39;d&#39;} . A*B # *로 교집합이 되지 않음 . TypeError Traceback (most recent call last) &lt;ipython-input-8-47896efed660&gt; in &lt;module&gt; -&gt; 1 A*B TypeError: unsupported operand type(s) for *: &#39;set&#39; and &#39;set&#39; . A &amp; B # 요것도 교집합 가능 . {&#39;c&#39;, &#39;d&#39;} . A.difference(B) # 차집합 . {&#39;a&#39;, &#39;b&#39;} . A-B # 리스트에서 가능하지 않았던 - 로 차집합 가능 . {&#39;a&#39;, &#39;b&#39;} . a=set(&#39;hello&#39;) . a . {&#39;e&#39;, &#39;h&#39;, &#39;l&#39;, &#39;o&#39;} . for i in a: print(i) . e h l o . 순서가 좀 이상하다 $ to$ 집합은 원래 순서가 없다. $ to$ 인덱싱이 불가능하다. $ to$ 슬라이싱도 불가능 . a[0] . TypeError Traceback (most recent call last) &lt;ipython-input-72-6a1284577a36&gt; in &lt;module&gt; -&gt; 1 a[0] TypeError: &#39;set&#39; object is not subscriptable . 집합 컴프리헨션 . C={2**x for x in [1,2,3,4]} #2^1, 2^2... . C . {2, 4, 8, 16} . . (5) dict . 사전 . boy: 소년 | girl: 소녀 | . girl 을 찾음 $ to$ 소녀 . mydict={&#39;a&#39;:[1,2,3],&#39;b&#39;:[3,4,5]} #집합형으로 선언 . mydict[&#39;a&#39;] . [1, 2, 3] . mylist=[[1,2,3],[3,4,5]] . mylist[0] . [1, 2, 3] . mylist[1] . [3, 4, 5] . mydict[&#39;a&#39;] # index가 아닌 내가 설정한 key로 집합을 찾는다! . [1, 2, 3] . mydict[&#39;b&#39;] . [3, 4, 5] . mylist[0]+mylist[1] . [1, 2, 3, 3, 4, 5] . mydict[&#39;a&#39;]+mydict[&#39;b&#39;] . [1, 2, 3, 3, 4, 5] . mydict . {&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [3, 4, 5]} . mydict[0] . KeyError Traceback (most recent call last) &lt;ipython-input-48-1529edbf7ad5&gt; in &lt;module&gt; -&gt; 1 mydict[0] KeyError: 0 . mydict[&#39;a&#39;:&#39;b&#39;] . TypeError Traceback (most recent call last) &lt;ipython-input-49-0cfefbf5c1da&gt; in &lt;module&gt; -&gt; 1 mydict[&#39;a&#39;:&#39;b&#39;] TypeError: unhashable type: &#39;slice&#39; . {&#39;a&#39;:(1,2,3),&#39;b&#39;:(3,4,5)} . {&#39;a&#39;: (1, 2, 3), &#39;b&#39;: (3, 4, 5)} . dict(([&#39;a&#39;,[1,2,3]],[&#39;b&#39;,[3,4,5]])) . {&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [3, 4, 5]} . 딕셔너리 컴프리핸션 . X={x:x**2 for x in (1,2,3,4)} . X . {1: 1, 2: 4, 3: 9, 4: 16} . X[4] . 16 . 이거 인덱싱아니야? . 인덱싱은 아님 (하지만 마치 인덱싱처럼 보이기는 함) . X[-1] . KeyError Traceback (most recent call last) &lt;ipython-input-76-5864bf9e7d00&gt; in &lt;module&gt; -&gt; 1 X[-1] KeyError: -1 . X[2:5] . TypeError Traceback (most recent call last) &lt;ipython-input-77-14e849fefbc5&gt; in &lt;module&gt; -&gt; 1 X[2:5] TypeError: unhashable type: &#39;slice&#39; . mylist . [[1, 2, 3], [3, 4, 5]] . mylist=[1,2,3,4,5] . mylist[-2] . 4 . X[-1] . KeyError Traceback (most recent call last) &lt;ipython-input-85-5864bf9e7d00&gt; in &lt;module&gt; -&gt; 1 X[-1] KeyError: -1 .",
            "url": "https://kimha02.github.io/ham/python/2021/07/15/python-2.html",
            "relUrl": "/python/2021/07/15/python-2.html",
            "date": " • Jul 15, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "(노트) 우분투 포맷 및 개발용 서버 셋팅",
            "content": "[참고] 교수님께서 공유해주신 자료를 본인이 이해하기 쉽도록 (약간) 수정한 자료임. . About this doc . - 우분투에서 여러가지 개발환경을 설정하는 방법을 포스팅 하겠다. . - 이 포스트는 우분투를 메인OS(사무용+연구용)로 사용하고 싶은 사람, 우분투를 활용하여 개발용 서버를 구축하고 싶은 사람에게 모두 유용한다. . - 이 포스트는 2080 이상의 GPU를 활용한 학습을 원하는 사람에게 유용하다. . - 이 포스트는 R과 파이썬을 동시에 쓰는 사람에게 유용하다. . - 이 포스트는 Rstudio, Jupyter Lab을 동시에 쓰는 사람에게 유용하다. . - 매년 조금씩 셋팅방법이 다른것 같다. (버전 업데이트 시 유의하여 노트를 참고할 것!) . &#54620;&#44544;&#49444;&#51221; (&#44060;&#48156;&#50857; &#49436;&#48260;&#51068; &#44221;&#50864; &#49373;&#47029; &#44032;&#45733;) . - 아래와 같이 커맨드에 친다. . ibus-setup . 이걸 치면 IBus Preferences 라는 창이 나오는데. 여기에서 (1) Input Method 탭 클릭 (2) Add 버튼 클릭 (3) Korean 선택 (4) Hangul 선택을 한다. - 위의 단계에서 Korean이 안보이면 Language Support로 가서 한국어팩을 설치하고 리부팅 하면 된다. (보통 실행하자마자 알아서 설치되더라.. 설치가 안되면 Install / Remove Languages... 이라는 탭을 클릭해서 설치하자) 리부팅을 꼭 해야한다는 것에 주의하자. - 이제 Region &amp; Language로 가서 설정하면 된다. . &#44536;&#47000;&#54589;&#52852;&#46300; &#46300;&#46972;&#51060;&#48260;&#49444;&#52824; . - 전체적인 내용은 여기를 참고하자. . - 우선 gedit를 열고 아래를 복사해서 붙여넣는다. . blacklist nouveau options nouveau modeset=0 . - 파일이름을 blacklist-nouveau.conf로 home에 저장한다. 그 다음 ctrl+alt+F3을 눌러서 까만화면으로 간다. 아래입력한다. . sudo -i . (sudo는 window의 관리자권한 쯤으로 이해하면 편하다!) . - 아이디와 비밀번호를 입력하고 루트권한을 얻는다. 아래를 입력한다. . sudo cp /home/cgb2/blacklist-nouveau.conf /etc/modprobe.d sudo update-initramfs -u exit . - 재부팅을한다. . - 커맨드에서 아래를 실행하자. . sudo apt install gcc sudo apt install build-essential . - 그리고 드라이버 설치파일을 다운받는다. 앤비디아공식홈페이지에서 다운받자. OS를 리눅스 64-bit으로 선택하고 검색을 누르면 다운받아진다. 다운받은뒤에는 파일이 있는 폴더로 이동하여 . chmod +x NVIDIA-Linux-x86_64-410.78.run . 를 실행하자. 보통 NVI까지치고 적당히 탭을 누르면 알아서 뒷부분이 완성된다. 이 과정은 추후에 드라이버를 실행할수 있도록 권한을 풀어두는 것이다. . - 그리고 아래를 실행한다. . sudo ./NVIDIA-Linux-x86_64-410.78.run . - 그 다음 드라이버가 잘 설치되었는지 확인한다. . nvidia-smi . 표가 나온다면 정상적으로 드라이버가 설치되었다는 것이다! . &#50500;&#45208;&#53080;&#45796; . - (아나콘다 설치) 아나콘다를 다운받은 폴더로 가서 아래와 같이 실행한다. . bash Anaconda3-2019.03-Linux-x86_64.sh . 대충 bash Ana 정도까지만 치고 tab을 누르면 알아서 완성된다. . - (환경만들기) 커맨드를 키고 아래를 실행한다. . (base) conda create -n py38r40 python=3.8 (base) conda create --name py38r40 python=3.8 . 둘 중 아무거나 실행해도 된다. 파이썬 환경이 너무 높으면 나중에 conda tensorflow-gpu가 먹히지 않으니 환경을 만들때 파이썬버전을 3.8.x로 하자. (현시점 2021년 2월25일기준 3.9.x이면 conda tensorflow-gpu 가 동작하지 않음.) . ssh&#50672;&#44208; . - 처음에 ssh를 연결하기위해서는 연결당하는 컴퓨터에 가서 아래를 실행해야 한다. . sudo apt install openssh-server . &#51452;&#54588;&#53552; &#50896;&#44201;&#51228;&#50612; . 1&#45800;&#44228;: &#51452;&#54588;&#53552;&#47017;&#49444;&#52824; . - 콘다 가상환경에서 주피터랩을 설치한다. . (py38r40) conda install -c conda-forge jupyterlab . . Note: 사실 위에서 주피터랩을 따로 설치안해도 주피터랩이 잘만 실행된다. 하지만 이렇게하니까 나중에 R커널을 만들기위해 IRkernel::installspec()을 실행할때 에러가 난다. . 2&#45800;&#44228;: &#54056;&#49828;&#50892;&#46300; &#49444;&#51221; . - 주피터랩은 보통 로칼로 접속하는데 이를 원격으로 접속할 수 있게 만들어보자. 우선 커맨드에서 아래를 실행하자. . (py38r40) jupyter lab --generate-config (py38r40) jupyter lab password . 3&#45800;&#44228;: jupyter lab &#54872;&#44221;&#49444;&#51221; . - 이제 /home/cgb/.jupyter/jupyter_lab_config.py 파일을 연다. . - 아이피주소를 바꾼다. (port는 선택) . c.ServerApp.ip = &#39;192.168.0.4&#39; c.ServerApp.port = 1306 . 여기에서 192.168.0.4 는 내부아이피다. 고정아이피가 있다면 고정아이피 주소를 쓰면 된다. . CUDA, cuDNN, tensorflow, pytorch . - 콘다환경으로 가서아래를 실행한다. . (py38r40) conda install -c conda-forge tensorflow-gpu (py38r40) conda install -c conda-forge pytorch-gpu . . Note: conda에서 가장 오류가 적은 것을 찾아 설치한다 -&gt; conda-forge에서 가장 오류가 적은 것을 찾아 설치한다 (?) - 그러면 알아서 CUDA, cuDNN, tensorflow, pytorch 가 설치된다. . Note: 예전에는 CUDA, cuDNN을 따로 설치해야 했는데 세상이 좋아졌다. . &#51452;&#54588;&#53552;&#50752; R&#52964;&#45328; &#50672;&#44208; . - 콘다환경으로 가서 아래를 실행한다. . (py38r40) conda install -c conda-forge r-essentials=4.0 . 이러면 콘다환경에는 R이 깔리고 base에는 R이 깔리지 않는다. 그리고 콘다환경에서 R을 실행한다. Rstudio가 아니라 커맨드에서 R을 실행해야한다. - 그리고 IRkernel을 설치한다. . install.packages(&quot;IRkernel&quot;) . - 그리고 아래를 실행하면 주피터랩과 R환경이 연결된다. . IRkernel::installspec() . - 이제 주피터랩에서 R kernel을 사용할 수 있다. . Rstudio server . - 이제 Rstudio server를 설치하는 방법을 다룬다. . Warning: 보통은 (base)에 R을 깔고 그 R과 Rstudio를 연결한다. 즉 아나콘다 기본환경에 R을 설치하고 그것을 Rstudio와 연결한다. 하지만 아나콘다 기본환경에 R을 설치하면 가상환경에서 설치된 R과 호환이 되지 않아 여러가지로 복잡한 문제가 생긴다. (근본적으로 주피터에서 접속하는 R과 Rstudio에서 접속하는 R이 서로 달라지게 된다.) 이러한 문제를 방지하기 위해서 본 포스트에서는 아나콘다 가상환경에 직접 R을 설치하는 방법을 다루겠다. . - 먼저 Rstudio를 설치한다. 참고로 Rstudio server 설치하는법은 여기를 참고하라. 요약하면 터미널에서 아래3줄을 입력하기만 하면된다. . (py38r40) sudo apt-get install gdebi-core (py38r40) wget https://download2.rstudio.org/server/bionic/amd64/rstudio-server-1.2.5033-amd64.deb (py38r40) sudo gdebi rstudio-server-1.2.5033-amd64.deb . . Warning: Rstudio 1.3x 이상을 설치하지말고 1.2x를 설치해야 한다. 이상하게 1.3x이상은 후에 서술할 Gregor Strurm가 그의 깃허브에서 제안하는 방식이 잘 동작하지 않았다. 이는 알려진 문제였고 이를 해결하는 해결책을 서술한 스레드가 있어보이긴 했지만 나는 그냥 Rstudio 1.2x를 설치하고 쓰는 것을 선택했다. . - 이제 Rstudio 설치가 끝났다. 설치된 Rstudio를 아나콘다 가상환경에 설치된 R과 연결해보자. 우선 아래를 실행한다. . (py38r40) sudo apt install uuid (py38r40) sudo apt install git (py38r40) git clone https://github.com/grst/rstudio-server-conda.git . 위에 두줄은 Gregor Sturm가 만든 어떤 프로그램을 쓰기 위한 사전준비작업이다. 마지막줄을 실행하면 Gregor Sturm가 만든 프로그램이 다운받아진다. 이게 프로그램 설치가 완료된것이다. 이제 컴퓨터 껐다 킬때마다 아래를 실행한다. . (py38r40) ./rstudio-server-conda/local/start_rstudio_server.sh 8787 # use any free port number here. . 이제 192.168.0.4:8787 따위의 주소로 접속하면 Rstudio를 쓸 수 있다. 참고로 system-wide Rstudio server를 죽여야 할 때가 있다. 그럴땐 아래 명령을 치면 된다. . (py38r40) sudo systemctl disable rstudio-server.service (py38r40) sudo systemctl stop rstudio-server.service . sublime text and TeX (&#44060;&#48156;&#50857; &#49436;&#48260;&#51068; &#44221;&#50864; &#49373;&#47029; &#44032;&#45733;) . - &#39;Ubuntu Software&#39;에 가서 &#39;sublime Text&#39;를 치면 다운받을 수 있다. 다운받은뒤에 &#39;file&#39; -&gt; &#39;open folder&#39;를 활용하여 깃허브의 로칼저장소를 열어두면 편리하다. . - 아래를 실행하여 TeX을 깐다. . sudo apt install texlive-full . - 이제 sublime과 latex을 연결하여보자. 여기를 참고하자. (1) sublime을 키고 &#39;Ctrl+Shift+p&#39;를 눌러 &#39;Install Package Control&#39; 선택 (2) 다시 &#39;Ctrl+Shift+p&#39; 를 눌러 &#39;Package Control: Install Package&#39;를 실행 (3) 그러면 바로 검색창이 나오는데 거기서 &#39;LaTeXTools&#39;를 입력해서 실행 (4) 다시 &#39;Ctrl+Shift+p&#39;를 누르고 &#39;LaTeXTools: Check system&#39; 선택. 모두 &#39;available&#39;이 나오면 잘 설치된 것이다. . - *.tex파일을 열고 &#39;Ctrl+b&#39;를 누르자. 처음이면 어떤 메뉴들이 보일텐데 그냥 &#39;Latex&#39;을 선택하자. 그러면 코딩결과가 pdf로 나온다. . - (수식미리보기) &#39;Perferences&#39; &gt; &#39;Packages Setting&#39; &gt; &#39;LaTeXTools&#39; &gt; &#39;Settings-User&#39;를 선택한다. &#39;93번째라인&#39;에 &#39;preview_math_mode&#39;를 &quot;all&quot;로 바꾼다. 그러면 수식들이 미리 출력된다. 그 외에도 자유롭게 셋팅을 조정할 수 있다. 원래 셋팅은 &#39;Perferences&#39; &gt; &#39;Packages Setting&#39; &gt; &#39;LaTeXTools&#39; &gt; &#39;Settings-Defaults&#39; 에 있다. .",
            "url": "https://kimha02.github.io/ham/%EC%9A%B0%EB%B6%84%ED%88%AC/2021/07/06/%EC%9A%B0%EB%B6%84%ED%88%AC-%ED%8F%AC%EB%A7%B7-%EB%B0%8F-%EA%B0%9C%EB%B0%9C%EC%9A%A9-%EC%84%9C%EB%B2%84-%EC%85%8B%ED%8C%85.html",
            "relUrl": "/%EC%9A%B0%EB%B6%84%ED%88%AC/2021/07/06/%EC%9A%B0%EB%B6%84%ED%88%AC-%ED%8F%AC%EB%A7%B7-%EB%B0%8F-%EA%B0%9C%EB%B0%9C%EC%9A%A9-%EC%84%9C%EB%B2%84-%EC%85%8B%ED%8C%85.html",
            "date": " • Jul 6, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "(공부) 파이썬 객체 소개_0차원 자료형",
            "content": "객체? . 본질적으로는 객체는 메모리 조각이다. | 파이썬에서는 모든것이 객체이다. (값, 연산, 함수, 클래스, 컴파일된 코드) 예를들면 숫자(99)도 객체이며, 파이썬이 제공하는 연산들(더하기, 빼기)도 객체이다. | . | 내장객체의 타입을 알아보자. | . 0&#52264;&#50896; &#51088;&#47308;&#54805; . (1) int&#54805; . a=333 . a . 333 . (2) float&#54805; . a=1.2*3 a . 3.5999999999999996 . (3) complex&#54805; . a=1+2j b=2-2j c=a+b . (4) bool&#54805; . a=True ## a=1로 생각해도 .. b=False ## b=0으로 생각해도 .. . [$ ast$] &#54805;&#53468;&#48320;&#54872; . a=3.6234 #float . b=int(a) #float-&gt;int 형태로 변환 . b . 3 . a=3 . a . 3 . float(a) #int-&gt;float 형태로 변환 . 3.0 . int(True) #bool-&gt;int 형태로 변환 . 1 . float(False) #bool-&gt;float 형태로 변환 . 0.0 . float(3+0j) #complex-&gt;float 불가 . TypeError Traceback (most recent call last) &lt;ipython-input-41-262acd6bef5b&gt; in &lt;module&gt; -&gt; 1 float(3+0j) #complex-&gt;float 불가 TypeError: can&#39;t convert complex to float . [$ ast$] math . pi #우리가 아는 파이(원주율)가 바로 나올까? A:안 나온다. . NameError Traceback (most recent call last) &lt;ipython-input-45-604074d5eb00&gt; in &lt;module&gt; -&gt; 1 pi #우리가 아는 파이(원주율)가 바로 나올까? A:안 나온다. NameError: name &#39;pi&#39; is not defined . import math math.pi #math패키지를 사용하면 바로 파이가 나온다. . 3.141592653589793 . math.e . 2.718281828459045 . math.sin(math.pi/2) #삼각함수 . 1.0 . math.sqrt(2) . 1.4142135623730951 . dir(math) #math 안에 있는 함수 확인 . math.??의 사용법을 아는 방법? | . math.sqrt . &lt;function math.sqrt(x, /)&gt; . (의문) math.에서 .을 왜 항상 붙이는가? . (요구) . 을 안붙이는 방법은 없을까? . from math import pi . pi . 3.141592653589793 . math.sin(pi/2) . 1.0 . from math import sin . sin(pi/2) . 1.0 . abs(1+1j) . 1.4142135623730951 . math.sqrt(2) . 1.4142135623730951 . [$ ast$] &#54028;&#51060;&#50028; &#48716;&#53944;&#51064;&#54632;&#49688; . 빌트인함수의 종류에 어떤것이 있는지 확인하는 방법? . https://docs.python.org/3.8/library/functions.html | . import builtins . .",
            "url": "https://kimha02.github.io/ham/python/2021/07/06/python-1.html",
            "relUrl": "/python/2021/07/06/python-1.html",
            "date": " • Jul 6, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://kimha02.github.io/ham/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post12": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://kimha02.github.io/ham/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "### 하영이의 공부용 블로그 . Since 2021 | python, R 중심으로 | 자주자주 올리는 것이 목표 | .",
          "url": "https://kimha02.github.io/ham/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://kimha02.github.io/ham/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}